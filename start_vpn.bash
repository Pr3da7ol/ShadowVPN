#!/bin/bash

# ==========================================
# SHADOW OPERATOR LAUNCHER | VPN SDC SERVER
# ==========================================

SCRIPT_TARGET="vpn_local_server_sdc.py"
PORT=8080
IP_RANGE_MIN=20
IP_RANGE_MAX=90
SCRIPT_VERSION="3.8"
UPDATE_URL="https://raw.githubusercontent.com/Pr3da7ol/ShadowVPN/main/start_vpn.bash"
export DEBIAN_FRONTEND=noninteractive

# Colores
ROJO='\033[0;31m'
VERDE='\033[0;32m'
AMARILLO='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_msg() { echo -e "${2}[${1}] ${3}${NC}"; }

# --- AUTO-UPDATE ---
get_self_path() {
    local p="$0"
    local resolved=""
    if command -v readlink &> /dev/null; then
        resolved="$(readlink -f "$p" 2>/dev/null)"
    fi
    if [ -z "$resolved" ] && command -v realpath &> /dev/null; then
        resolved="$(realpath "$p" 2>/dev/null)"
    fi
    [ -n "$resolved" ] && echo "$resolved" || echo "$p"
}

fetch_remote_script() {
    local url="$1"
    local out="$2"
    if command -v curl &> /dev/null; then
        curl -fsSL "$url" -o "$out"
    elif command -v wget &> /dev/null; then
        wget -qO "$out" "$url"
    else
        return 1
    fi
}

extract_version() {
    local file="$1"
    local v=""
    v="$(grep -m1 '^SCRIPT_VERSION=' "$file" 2>/dev/null | cut -d'"' -f2)"
    if [ -z "$v" ]; then
        v="$(grep -m1 -E 'REPARACIÓN DE EMERGENCIA \(V[0-9.]+\)' "$file" 2>/dev/null | sed -E 's/.*\(V([0-9.]+)\).*/\1/')"
    fi
    echo "$v"
}

auto_update() {
    local self_path tmp_file remote_version
    self_path="$(get_self_path)"
    tmp_file="/tmp/start_vpn.bash.$$"

    if ! fetch_remote_script "$UPDATE_URL" "$tmp_file"; then
        echo -e "${AMARILLO}[!] Auto-update no disponible (curl/wget o red).${NC}"
        return 0
    fi

    remote_version="$(extract_version "$tmp_file")"
    if [ -z "$remote_version" ]; then
        echo -e "${AMARILLO}[!] No se pudo leer version remota. Omitiendo update.${NC}"
        rm -f "$tmp_file"
        return 0
    fi

    if [ "$remote_version" != "$SCRIPT_VERSION" ]; then
        echo -e "${CYAN}[*] Update detectado: v${SCRIPT_VERSION} -> v${remote_version}${NC}"
        if cp "$tmp_file" "$self_path" 2>/dev/null; then
            chmod +x "$self_path" 2>/dev/null
            echo -e "${VERDE}[OK] Script actualizado. Re-lanzando...${NC}"
            rm -f "$tmp_file"
            exec "$self_path" "$@"
        else
            echo -e "${ROJO}[X] No se pudo escribir en: $self_path${NC}"
            rm -f "$tmp_file"
            return 0
        fi
    else
        echo -e "${VERDE}[OK] Script en ultima version (v${SCRIPT_VERSION}).${NC}"
        rm -f "$tmp_file"
        return 0
    fi
}

# --- VERIFICACIÓN DE RANGO IP (IFCONFIG) ---
get_ifconfig_ips() {
    ifconfig 2>/dev/null \
        | grep -Eo 'inet (addr:)?([0-9]{1,3}\.){3}[0-9]{1,3}' \
        | awk '{print $2}' \
        | sed 's/^addr://g' \
        | sort -u
}

get_rmnet0_ip() {
    local ip=""
    ip="$(ifconfig rmnet0 2>/dev/null \
        | grep -Eo 'inet (addr:)?([0-9]{1,3}\.){3}[0-9]{1,3}' \
        | awk '{print $2}' \
        | sed 's/^addr://g' \
        | head -n1)"
    if [ -n "$ip" ]; then
        echo "$ip"
        return 0
    fi
    ifconfig 2>/dev/null | awk '
        $1 ~ /^rmnet0/ {show=1; next}
        show && $1 ~ /^$/ {exit}
        show && $1=="inet" {print $2; exit}
    ' | sed 's/^addr://g'
}

ip_in_recommended_range() {
    local ip="$1"
    local o1 o2 o3 o4
    IFS='.' read -r o1 o2 o3 o4 <<< "$ip"
    [ "$o1" = "10" ] || return 1
    case "$o2" in
        ''|*[!0-9]*) return 1 ;;
    esac
    [ "$o2" -ge "$IP_RANGE_MIN" ] && [ "$o2" -le "$IP_RANGE_MAX" ]
}

check_ip_range_ifconfig() {
    if ! command -v ifconfig &> /dev/null; then
        echo -e "${AMARILLO}[!] ifconfig no disponible. Omitiendo verificacion de rango.${NC}"
        return 0
    fi

    local rmnet_ip current_ip ok match_ip
    rmnet_ip="$(get_rmnet0_ip)"
    ok=1

    if [ -n "$rmnet_ip" ]; then
        current_ip="$rmnet_ip"
        if ip_in_recommended_range "$rmnet_ip"; then
            ok=0
            match_ip="$rmnet_ip"
        fi
    else
        local ips primary_ip
        ips="$(get_ifconfig_ips)"
        if [ -z "$ips" ]; then
            echo -e "${AMARILLO}[!] No se detectaron IPs con ifconfig. Omitiendo verificacion.${NC}"
            return 0
        fi
        primary_ip=""
        for ip in $ips; do
            if [ "$ip" != "127.0.0.1" ]; then
                primary_ip="$ip"
                break
            fi
        done
        if [ -z "$primary_ip" ]; then
            primary_ip="$(echo "$ips" | head -n1)"
        fi
        current_ip="$primary_ip"
        if [ -n "$primary_ip" ] && ip_in_recommended_range "$primary_ip"; then
            ok=0
            match_ip="$primary_ip"
        fi
    fi

    if [ "$ok" -eq 0 ]; then
        echo -e "${VERDE}[OK] IP EN RANGO SUGERIDO: ${NC}$match_ip"
        echo -e "${CYAN}Rango sugerido: 10.${IP_RANGE_MIN} - 10.${IP_RANGE_MAX}${NC}"
        return 0
    fi

    if [ -z "$current_ip" ]; then
        current_ip="N/A"
    fi
    echo -e "${ROJO}[X] IP FUERA DE RANGO SUGERIDO: ${NC}$current_ip"
    echo -e "${CYAN}Rango sugerido: 10.${IP_RANGE_MIN} - 10.${IP_RANGE_MAX}${NC}"
    echo -e "${CYAN}[*] PROTOCOLO DE RECUPERACION DE RANGO:${NC}"
    echo -e "${CYAN}    1) PON EL TELEFONO EN MODO AVION (10-15s).${NC}"
    echo -e "${CYAN}    2) DESACTIVA MODO AVION Y ESPERA NUEVA IP.${NC}"
    echo -e "${CYAN}    3) VERIFICA CON ifconfig Y REINTENTA.${NC}"
    echo -e "${AMARILLO}[!] Continuar podria afectar rendimiento o consumo de datos.${NC}"
    read -r -p ">> Forzar ejecucion? (s/N): " confirm
    if [ "$confirm" != "s" ]; then
        echo -e "${ROJO}[!] Operacion abortada por verificacion de rango.${NC}"
        exit 0
    fi
    echo -e "${AMARILLO}[!] MODO FORZADO ACTIVADO.${NC}"
}

# --- CONTROL DE PUERTO ---
port_in_use() {
    if command -v ss &> /dev/null; then
        ss -ltn "sport = :$PORT" 2>/dev/null | grep -q ":$PORT"
    elif command -v lsof &> /dev/null; then
        lsof -iTCP:"$PORT" -sTCP:LISTEN -t &> /dev/null
    elif command -v fuser &> /dev/null; then
        fuser -n tcp "$PORT" &> /dev/null
    else
        return 1
    fi
}

kill_port() {
    local pids=""
    if command -v ss &> /dev/null; then
        pids=$(ss -ltnp "sport = :$PORT" 2>/dev/null | awk -F'pid=' 'NR>1{split($2,a,","); print a[1]}' | sort -u)
    elif command -v lsof &> /dev/null; then
        pids=$(lsof -iTCP:"$PORT" -sTCP:LISTEN -t 2>/dev/null | sort -u)
    elif command -v fuser &> /dev/null; then
        pids=$(fuser -n tcp "$PORT" 2>/dev/null)
    fi
    if [ -n "$pids" ]; then
        log_msg "WARN" "$AMARILLO" "Puerto $PORT en uso. Cerrando PID(s): $pids"
        kill $pids 2>/dev/null
        sleep 1
        if port_in_use; then
            log_msg "WARN" "$ROJO" "Forzando cierre en puerto $PORT"
            kill -9 $pids 2>/dev/null
        fi
    fi
}

# --- 1. GENERACIÓN DEL PAYLOAD (Self-Extracting) ---
generate_payload() {
    log_msg "SYSTEM" "$CYAN" "Verificando integridad del núcleo..."
    if [ -f "$SCRIPT_TARGET" ]; then
        log_msg "CHECK" "$VERDE" "Núcleo $SCRIPT_TARGET detectado localmente."
    else
        log_msg "GEN" "$AMARILLO" "Núcleo no detectado. Materializando $SCRIPT_TARGET (ULTRA SECURE)..."
        
        # INICIO DEL BLOQUE PYTHON PROTEGIDO V2
        cat << 'EOF' > "$SCRIPT_TARGET"
# SHADOW PROTECTED | DO NOT MODIFY
import base64, json, os, sys, zlib
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes

def _b64d(s):
    s = s + ("=" * (-len(s) % 4))
    return base64.urlsafe_b64decode(s.encode("utf-8"))

def _derive_key(passphrase, salt, iterations):
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=iterations)
    return kdf.derive(passphrase.encode("utf-8"))

payload = "eyJzIjoiSHlKbEVTS3hxeTZtQzgzZHRlSllGZyIsIm4iOiJxQ1R4dWxNRGF2YzR1aHZYIiwiYyI6IkxkQ0t0b20yeURXcWd4d3psOFhLOGdTUjYweWktOHdnZ3lkSDBTZHFnNXk1NGV4MGhDaWkyc1ZqT01uWUx5U3N3cXUwZllZZzlPWk5Zd3VWNkNjb1ZHdzgwTFR5a1IwcG5VT0l4WXR0eHFRWUkycVBHSzBaaFBFa0hqWjljMnlpaU9nQmtaMGFHUDBWOU1oZVVadGdfb1JFb2FnMnA2WTh6bkwzcnZsd3dPbFY0Ql9iUWJfSmhoNDVyWENqOVpub2tkV014XzZ1S1JaT3c5NW5hQTh6anNtY2g4Y2dCUDAzNGxqNjh2dnNzTTQxNDFWcGFaRTFwbFR2MkpuVmsxQndXRTJIY19ZbUlTbmhyc1ZrWmEwRmJsS1U0WE1pTUlDVThkZ2wyVDE1Y29rWmRGNksxcUhWUzFqNTVkTzQ4WDVZVzN2NXh4VU1xVGFaNG1HOF95R3VEMzZLdTBiZ0VPSjVIZzhvaVBDbXEybldUb3FUSVdtbDNwNEdhRndSLVBJelZYYW43Tm1HWnM3eGRGUkpGbEJtRVVBTFZsNndfSjBCZXgyWXJ0SE9TOGJHT01UU3p4RzEyYll2bC1iNV9tRWpuQkdIUVdEWkxIYS1XRVdtZFJoMFZ5VFRONzNUQkJ5S01qYlFINFZmQzBvZ1k3YmJLdnFkRks2ajRsdFd0R0JsUVNtQXBPdHR2VmV5MGVCS2RTbFVheU91dm83X0RWN1pkWVUtaEhFXzgxZ3UxVXlxSXNOazVQUnhPWENZVEFGMVl2R1hpWXRnYVhJQ2lfUmhPcUpJeU9aYUFOYXNYckJCS1M4Ylp4OXRXZkNYREM4M0lkR20ybDdITHhrb2Y3cjZ3RGN1cEFHakc3ODNQLTV2WHE3bFNvbkJSU0JLTHdzdnZXQ2VNU0s3aWNJQWFGdXlBcGp3bWhZdHdDMjY4N3I1N1JnYTdCOWItRWowMHFZcGhMejhwUkRIZHlhZHlHdWo3YVpzcEtzUzFFbWhQSXRpWUZ0dm96VVFpTmZWSkZSdHJTLVE1cWRpQ0EtdXB6RXZSb0JMSnNxQVcycEpDU2l4c0VkR1h6NC04ZHZlSGdGbVlCN01jVF9wU0VtRDA1b1BCYlk4SDVWUlZWYTZLUXV5ZVVVYjFUTkJWb01TOExmMHJYcVpDeUVvTVBZc1ZndHUzYU5HQWczdGJ1Q3ZzbmoxMDl2SEdGU2dfV1pQWFpUWEl3aFhmVG9STFIxa1VXYWZiU09VeEdsV25fMEdlWVpTMXJtUHRpU0I3UC1Ca3Q4ZlBVVkxhTWxncWNUM1RzVmd1WWF6czVaQ3JIQmJDbFFveFBKMTNyc3Y4cjhRSnBxZnhCM2dsdDZCNUdFMTVMRVF5Q0I2OW5UNmdNQjhwTnpNUEpIYWtzalJjV1B6X19QVVFRYkk4Ty1QcUhFR05sV19YUnAtcmZ6b01WS2ZVVTdBemhiYm5NSlRibm1xRFdKVk1nekhUeVFaTWw5UUlmWVhxc0N2bFJrZEVEcTEtYkdkQ0RyTHIyaWVqenNuVUdwVmx6dnI4NXdMVUdVSy1PcWlYaWFaWXFiRUxLU21neGlmeXNObVhUVlhZeEd1SVdnek1CejFqdjNKM19lYUcwb0lWVnNIM3I0UDZjdlN4cklsX2VZVm42UUZfSkd0WjNPaW1IdDhhTHR5RnlnOHE2NERzWlZtX3BzYUNUYnNIbFduRndfQzRHTWFBZ0NBQ2xjbDhhM0k0YmNvLXhDM2E4aS1QTm9CcGN3LTVELTBtOVJrUUw1SkF5NXI3UUFiR1ZodjJwQ19pTWNCREUydDNaZ3F3Vi1fQ0dpMFpUQ2pXQWd5Zmp1QTRXTElTS1BxUmZOOW5HSTliNkREZ0hYTDFKQzB4VHVvd0c2T1NoSDZJUk45M1pGb0R2UDhNMGRJSlBRclY2MEZHNFA2VERHMWpmTWZJTjltYlNLZmptT3dyRHRUcWZCdmhjOUZGRlY3OWxscTNYYzJvSUh0MEhSX3dBc2NjZTJ2Q1NMUjc3c0M5YXlzampfeUo1elpxZ2dsT2VSZU94OXFYN2JpZkhLZlVZaTNFMUpWdE5WWHRrMkowVWFyVkdmaUlCRHNxY3A1VTRUaXBJSXl4bVpsTjMteWRQeExaRkZ0TjhMdzVZc2FRaC1WNUdBMVpmakxaR1JqaW1rOEJqVFNIcUNSSUlhamFXSy1qNElTbGQ3ZFNDOW82RDBPS3ppek9oRDhFVTRSYjF2SkpES2xQQTRSbWt2QWMwWktsdHJvdW9seHdjcllxNFJOZVAxUTZzT0ZUaEw1dTlLdDRVM0pUTHpRb1cxTXhDMlctWUlDcm40ZHdldFVSblhQVU9BbjhkNHhaWmtDS0xYMXRUU3hjcmdZWHlNR1RIM0RNc1NkZ1FRbmtWNTFlWjZuY2FDWE43akFDZFlIbjZOcE9Ha2VXLWRZZDZGYklncE9hLXFnWG1td1BlaVpzQkhRUXNmRjFSTVdnVUkxQ2NKNFVlSkZ4aXN0NVA4SHhlU3FubGgwa1ZwYzgyekNyYmF2R0hZanByaHBUeE5SN1hITlFYVm5GelBzUHJLWlpLc0N5STdaVFVVRG5aTl85cUFDd0ZXQnRSYmJlVEVFUEZ0dmVaRDcwNlVzNlpZcjRETjY5R0xCMDNZNnByOUNQeHdScHpFcGJBc1hCU1NWUFBRRmdJSUdJN1JvbGVWejFrU21BYnJlOUVScXBtZUgzVUxibHdLY2tBNmZGc3B2eGFMMjdCc0Q4aEx5anBoZ2ZTUE5hd3VnLWdWZ2RJeTFDRy1WUy1FM1hjdm80VTZTaFBsOHdUVWJPV0V4cGdYVTc3YkNxZkhJNG9kZF9CWGFtMTYtY3IzVjBVRUo2by1oRkduSGFaVEZUaldEZXBRN0hRUnV3Vk5uLV9pWWJBRjdLbGE1SHBTN0VuOGRpN1dGM215aGU3OGwxZTQtMFhCcnlZa1U4c2pMZjV0Wjg3NFdxbEJuSDVyR1hwV1hocFZRSkFwVmEtTGVvWXFSMnBaeUptQ3VvNzc4Uy04d080ZEhzN1dtRFc2bjllN1J6amQxTDg5UjI1M2RlZFk0bUJEU1psWGVDbGJFYVY0VThQYmJPUllRanhiV2p2c0I0VXFkU0VLS2ZFTWlFbG5RRGloU2pYTTk3MjM5T2hSQ2d0LWs4Mk9Na0xmSTZFa1BoSmpyVDE1bXVwY0pZRjJFd2FHMHNPWDJqMDRNckxncE56NGF3cWFWNlVZRlZfeEZRMlhZLUdPRWFzd1czUVNoVTJkbjJ0REFWVjR6N1dEdldEeDl0RnNMajlBd19DTmtWZmpQbm1wQUc4MEUzbHF0Z2hKNjhUVGpSZXc1UE5qbXlBV2hpOGh0cndOVE91aDRLWWZvREFXcHdyTEhnUmpMSnMtU2s5ejZkNno5WXluUlJDYmg1OGRsYXdNa3lmMVZFZ1Q5LXhrelNfbjFEelR4MENTYVNfNXN4Q2s0MGg3cnJyU1B1TUQ5SmVEUndEREFtZEctcFU2NFZtVWt5bEEtNElod3QzYTRFa1k5eldmWW84Qm1tQy0yNFNhRERYOFBtYnhRckw5S1A2NmFkTEpKQzMtVVhaaVhTOXYxT3NLQ3RXa00zZGotUTNwXzAtcVIxVTZpTEJaUGdoN3N0YTYybFFzY1E4RWJ3dUJDMDAwQkkycE9fVWx0Z2l6T1BnWWFfNFlISjFVQUxnVTB3a3BoODNDODVXSkxmdnBKZF9RZ3RtaEtKeUN6bUxleGJZVFdMeWJIcjBNMF9keGlTYjZLV18zQk5JSEI5RG1WZ1VNTzNoSWluT1g0QVBsWWpQTXFwamE0UElNeU9rQWV5V1haU2R5VExqSWxsWGtILXI3X1JfVlpWcDdHOTBDVlllbFRsODJFNmFlMmFIRWVrZHFScHZ1QVVmZVJnU0J0Y1hjVzFkcjdsRW1HZUtZOHZmVmp3MWFqR2Q3elloazAxRV9fMW5EZENza3JpZG9mTEhjS1FQZld6TDBjLUJsMWIxSEhmcHdKOEFkMFhSQ3ZZWHpFT2tTOW5jMjYyaXBXVUhHY2hNYTl2WFhhcWIzcWhZZG1KUklfSVJLaWdYRk5fRGk4X1djZWJ3NzhaaEgydG1JNEdZWEl4RGQwUDA5QkVKUzBzTlp0N0ZkRUkwWjJiV0RvMGNxNDJ5X2tRQzZNczRDM3hfN0xJUEJSUlh5U1B3OFA2Tk4xWlREVVg2UWs4TGVIS09VVG9zajBHQVNXNXMwU1VnN0JuZ19jQWh2azBDZFhQVnJyZ2F3YVNZOXNSSTZJY0RaZVItbi1XbWdWRjdhYlQwNGctbUlFVV9JWTJsTkFiWHh4N0wwVmNLaXQ5WDVWalRFd0IzNDl0SGIzU25JWUstMHlQeG5zNDZuVUxIVDJWTll1UC1aT3VBU1lHOW9SUkVoRmNlLXQ0WkxhZWFyTFZHcGJ6MUFUWC1PbjEzQXV0bndyT095TzVYTWxVUFhoRG1XTU02VTBzVTVnLWFvbnpvWDlTRU5EM3VZZGpTZXp3YWhINGlJemhLRmdLMVRCRkJIelZNYUdxZk84YURIUVhTVUFsbktjVlNzOUdFYkhSNVRJdDJaSTBKLUZYNnBCTjVKWDJWTDBEOE0tT1hoek1SWHNvWWVUS2l1Mkh6VWVTNHMwdFZjMjVvaHFpWWpNTE15MnFRbTlKN2VGUDhtN3I1MkczOWdGTlhBWXctSGRhRmtEV2did2dVZ3JmdzFLU0s3NEZaVnlVa2k5TWdYV1FEYUEzeUU1Y0t6YkdJYjdhWmVmVUxfRkxVaF9Od1FYbER0dmoyMEhJMk9GejNlZ0dHbm1sa0FjRTBxcmlvYmE3ZE1uSDFkaVpaWEVxX0tPOF9UOHoyTU1FQXJkRXV1U21zbDBPcUkxeF9WNkZSSUFRcnR6UXlJeEEyYWo5a0o5UjVxOENiSnVpMFVkTER5WWVlQXFxVHp5cHRBN0V0Y3dVRGd5eWE5ajdvZjVQWVk2a1NQV2tTYTh4a3VpX1FPd01zSnE5dzU4STZSREFKN0hzMG04R3BCaWdGc0JUOVFJcUdlaWhqU0I3UEVqUVh3Vzlxa3ptRVdiVmg5WnRvZTQ1cEtNYXNBYV92QWdudDEzd21qX0dBNkpDemlXMFFhZ3RoWDh1azdfRU5KakZHdXlRWGJhcm5nd2R4UThZcXFRX3pRNkxEZlJjdHJpUlM0YmFLN1k2Z2NLRy1meVg0UHZVY0JiOGZpM1NEUEtUQmNpcTEteHRTNXkzUUJ2aXBBOVdGejRJWFBtcjRpYWFyZXF5U1IxNzloVWpzSks5a0Y1T05uR1BiOHRkUS1SRjM1SDBQQThPT2p1WTBmQjV0QWZyNjJ0Z19WWkFudGlpTVJKYVhkQmZEQ25rMGJlaE1lZ2tFMEJEeERxakt5WHZnc1M4aHZKZnpTQVB2b1J2TWdWcm9MV0NYVTl6eUVVSXA4R2JpXzRCVk5XdHVhZ19WcXN6MUxWODJSeEpram1NMzRYXzJRUXR5dURWRzlWYTJxNUgybUExbEUzRVQzaVVGWi1CSTV2UHlyNmo2bWxrS0dSTEltV2xiUUxkb2h6UTFRLTVtMWF3cE9EUThqMlphMFJaMnY0OXJ4TDNCMnZseF9RTGg2emR6bGNVOVJOQVdzeW5xMlBDUnZ3dFhTWG1FWDh0bkZBSWU4dWFTNExEdHFVd3ZtZEZTU0VOcEpnamxjTjVGcFhUTF9adjk3MVJJcDJsd0xmcm5hZTl2YnFNTUEtTVlWMlV3MjNhQ3RFbm8xS1RNTlk3TDVUX0JmZVhlSTR3ZHNHNDItNFhtVUxXYzhQREtXMWcwTzh6WEFHcnV5ZS1USnFfVGRCRmo0cWRCNDM2anQ1cHFIRm1kOVRtTVRjdnpVRVhuTjdjS1VDcFNmbXBMMlFRbUxSVDkwdkJPQk5jY0VMQW90dHh2S2FINl9Ha0ZkWkY0SlNSRU4zNml0YkJvYzBpb2xJVUxhRDZPSVN5NHFNb2luTi12RzJ1V1VIYWtzOFFVTzNPQUxmOFpNdkRoSEg4OFZqYlpRcW5OelV1eTNyRXlsbVUyLTVUU2I5RE4tdUpjZ09WdUE1cGprV2pScU5WLUtLZlJFaE5zRnZnODBZSTlIM1lBS2tMN2RZQmVPUVBFWk9heE5PVzdMMk53Y291ajZxVkEza0JmUVZQeVNrczBhWlVYdlV6aVgya19odVNIdEdWN216VXE3aVZmQS11NGw3NEVMZk11dnVMWTVveUp4dVhOazVmdkNHaC1PeExPWW9wMnhhVUJSdWE1emhYbGduY3VSR0RzTDAzeHJNdmpZdUNWeHVyUENLMWFnWDRMdmZhand0MF9VVEFhWmxJdXRRaVp0M3d6VzROZmlKSUlZbUJZN2hIZ2ZOSEVoekVCXzI5N0NvdWtnQ25uYVdoU2FiUFBvQWY2SVFpSEFDQnQ3SnliVFU4Y1RhUEtLN182Vy1qeHNHdFdHVHRpZnRhS1hCQldaczc4MWQ5akRfVmI0U08ybUk4bFdwYTJQdjNWQWdhZm5fQ203TmRXZ2w2dW43dVNvTF9JLU5NR1JrZERTSG5mVXJTTzJTUTMxX1FWTUhXUFhJMWl6NS1GeVRaZy1YLUVwVVlhQ0ExWVFHZ2wxQkp1a0dwSTl4VFVXdVFfcEhyM1VST29aV3R6SFdZUlotdnlKclpNOEg2bHRwbEhQR1F3TkJtX0tHWUZZRTkzMXNVdzQxSkowZ2ZfSzZRQzZhT2dJRU94Y29KLXQzVjZXdDhsMldsMjdGTEZRWjJtRTVKTnNXUGt5aXg1aHhTbTlWLUtBdmhEV2Q0c2xiZnA3enVqQ1NxN1lSRWZOd2RpZDV2dVJ4ZzhCT080ZVFSNUhnRUdZempUWW5pVkJhd3I1R1oyX1JWSTMtdkpQc3ZRc1JGSTFydENobk5lX29PV2dDOU52V1hKTnF3WVEyc2wtbUw3ZGVZZmttSHJ1QUhURTVmd2lMR0NpZ1BKWW9fb2Y1dTl5RmJuODJ2aFpWTFdWMElRdmNlWXAxYTRueU5XYUZpTExzMTlCamhqUWlHbTNadjR6Z2FaS1ByejNhTW5ZT1B0M0J3S3I3ZVBoVktwemF2eVhZdXlVVzh5N1RXQnNBTExCaUpTRVFaVWpXOFJ0aFoycUVOb1VSNnJUMjgwVnZUemhjQ29QMGc1UGQ3TkdheVpKdktkb3F0T1phSmlnYTU4UzRPM05BNl9lbFFoOWZzSjhWTTQ3Y3l3Q0lWcW1VVDVXUndkY3RJRHBFWkllMTN4WWVLbzhPeGotenlNMDJLck5jOEhxc2k3Z0V3c19sVkpMZ3lxZmRYX0pyRG1ldFRnbDEybHJBOTFLUFUzUUVrZlI3aHVERFM5b0x3Sm9wQl9Hc2o2Y1FHcVpveHJ3OGFSZGJzQm1xdE9Qck9pRGRCRmZIVW4ta2JOaGlMc2I3LXFmSnNpZ3dBWmpqOG5DVFp6OXRWZHg1WklWNHhWNDJGZ2tmaERxX2ZBNl9UbWEwZDBZdi1yU0pObEtHd3l5SV85aDY0UGxpNlNuQ195SnN0SG9VeWQzSk9MbTM5RlpvRl9ZR0NNUlJwOGVOVkp6LU90TGdiLUlON0ktTG5wUGUxRmM2SHBZdFloMW4yZHplNmVBQTZtOVN0dWlmblRqa25Pb1plNUxLRDNCbFJpVGxtSVlzREZZYndJWU8zLWJnR25CRU1hb29LdjVRNGkwVGN5TFQzYjVTQkhPTC1YS1NST0xkNmI1bU5FdXlmcW8xSVl5SkFNWEs2NlBHazR0TUJJeDg2NlB1WFF3NWdJdE1Pek5ZRjBCMm1pendmem1WTW54Y1RnQ2FmNVpmM3FLMXNuM2ZfQ3Z4QzZwY1M2S05WNFJYSTYyVUl6Ul9hVm9VSlc0Y2NzVTI2MU5qcnB6cnpoUTd6cTNnLW9ydkRva01USXM0dnI1TUkyc2tLVXY4SW95TkJQMV9uWUpGd0I5X0stNlpINDZGNldjd2dZVFdCb3RrejRjRkJSTjJpWnBPRjQ2NjIzVXdkRHZaN3Q0czVhY2FJQ3FJNHRYbnVfMGRqWmJuUEQyWmQ0REFlZUJ0Zkwtc08wNUVaeHlvNHFlSHFPbXYtVjlFYkVlNHA0S0h3QkFHMGpTbkFLZkpsNnpxamhUTklja29oY2xXS2xHa3ZKQWlfa3JpTFQ0ekY1UFM2NGFsR3dDeUtUaWlGX3lleFJfam5RMElOU2pPM0o0NWxjUndIc2xkM2VKbk1DcjlORWxTZWJHOVo0bHFMWi01bXYyT00yd21NbllWRWw2dnY0ek11X2V1OVdReDVfNmZwS2JQM2FLUWJPYUdaeXBIcHhlWHQyVVo5SjNNRlA2ZW40N01mbktsYjlmXzIyV0J0c25ibHNfSlFrbF8tRGx4VGVJM2gzQkYxRlhPd2VkMm1UajZCZmJpSG9IN0NicnNfNzc0Q3RBS2dBYm5FMHNpTGZpbzByNWdlcGFMV21iN1VPRGhFclpLeXBMVXQyTEJvRzlxZDJyRUNacEZfNGlUdGJOTDZCUkltcW14UFo4RDlQR1FIelJySHY0Y3ZhRTN5SUdqMUN4MHpDdm1EN290NndEVUx4MDRIaE9nUU1WN3d4QUZfUktnakhURTJjMmNoZzRKaWJDSDBZU19RbHU2em9VNU5YOEdZZUZXR1FnbVdTUi04UUJYbC1Qd1lOcEJ2WFozZW9OUVFTQURrRmk2VnV2a1pSUVVhY2xUTGtodFZkMDA3QjFXWk9yTy1mVHVBSEt5cC0xM01NN3o5bVpReE1WRVZVWjdUaXc0M283QkNMU3drclUwS2ZjSUhrZTVsN1loTGlTMENXMGowZ1ZaeF83VVpGMDl1cmx5LWhrb09RbG95Tll2TTBTU1pRSmtsMmQzaHZBTldLMGIzWVVYamROQlBGZ3lPVS1GOG4wYnJNQnZUMFZYdnlmQUpRbEs5Rm50UDFQWjBOcmdXbmFZNzNmU1FPcWpjb1p4OFhiNlJWQzRHY2MzaURGekdySl9ERTJqRWpzSl9vVDZEaDN5aHh0S1o3NHVYeUtJQVFwWEhTZ1NlOElON0Y4UklPVVpES21PbzE5Tm1GbnJEY2FzLWRET194QTc2eDU5NThjbnltYnM5SThCWDF2WDdYTzRybVpCbEtPdkZfYUs5azkwWGUxTTU5bWQtd3U0OEZza2otdXEwVElMcExyMTBOQlZYWDlHYXdKVHUyQ05rS1RpRENfbXpYeDlOS2ZuUFNqWFNsN2wwOVZJdEtBV185ckFtWDFJWTlnM0dyVl95S2lRS1c4b3laTmlrc19Md3NadlFwNXNna19WZXlOYTRhRGplZUJZeG9aRHhydzYzTm1PemN0WXcxWWFLVnFCSWVHUV9HbGJxUVhEbWZJZFB5d01mME9TdVBWaUdhRm44LUlRSzFJUExPUVc3S052OVR3TWQ3MkJfejZBanlOakJhUXdNcWhfLVdGR3FpMDkxUDhXMmstNkFjT1FVM2d3OUVIZHU3QUZ1S0hYbUlxUkZsSzZEaFJKQWVpNXlVY2RFc3BJMXVTVE9MbHNabWEzajJ2SFpHVmhQdEJLMXVNU29heEl2ZmdDNElZZWxLa3lBRGZOS0sySXJJbWFtNzkxQnA2WEFVemcxOXY3S3RrX1dhMy1kN1JqVW5kWXd0OGU1eXNjR19ZVURjM1hwbllKVlpEeUNkRTJtMXRDczlFWjZhekFDbnVWVThpemUxTmlDZHpzNkFfdkF6RkloUWxjWFRfdTZ4Yjl2aGFyYjFtQVlrU2FKS3p5SEhMNEgxTE5rMEs3eUIwOWRQSzZxMzNVTk9MX3VSZVRPNFZkLWFXbExSXzR5d3lEZ191YkJ1cTN1RU1Jdk1VRi1sQWpJMUVmVjh0Vkdkb09Ec21vYVR1UkRua09YQ2d0LW5DYXBFRldOd3YtSXJzRG1MNVpPLUt4bGk5dmMwTkNFWVNYWXF2WjBLbGc4a0ZmMGwzS2NxY3NIZVBuN0RJeldmWVczbEUzdV9nTjBjRGNOWHlzMjVTNTF3alZXcXc1b1BfejgzdllsZjlyc2NoOElCMDRtQTR3RFRmMkhWc2I5M0NZR2hGakVmeWhKeEplRWQyWGZqcV9nalVZRy1WN1pPMW9WVENMSjJ3bDVMdE02Rzd5cnVDY19TMkhQcnZOR2dJeXF5QWNvTk9uMXJoWEZFLVBqSzh0YnhYc0RuSHJ0WWpzQ1MxZDR2R3EyamVCUTVobXBDcWlpcm5BNTFibUl0TjA4TDRCd09vdjNsck1hOElyOUtqX2lqOEJWdHNrNEpCZkZ6TTB5NnZBa2E2S1YwWVY1a3N1NkhfMmhtdjFJbFhsOEpuT2xCenBPWFpHTmJualBRd19qWlY2aVBRTXI4bGVJQlJwMWFHOTBwZlMwWWExVWQ0S0k5bnYwTzl4bUtqZEpuTDdNdTYzZ0VCWV9QY1c2dEVzVXp6M0JkOXdCeklWejBDa1Mzb25kanhsQ0dDbXRXRmlURklGS2NGSlFyNVBaNmlQUXVGdENabHc5MFR5Z2xyQmVHWktTQldSMVFpUkZDMzRLRUFXZkxHRHBFd1UtdS1LWVVnSnRRem8yNjJ1b0dSTER2MjFzSVd2UmM1bEZPNUdWa3c5bzhfLUlIZ1Qtc3ZSdmZpVkl3cmhsRVdRcklLOGFzR3YxS2djSXR0VjhfYVVlTTBDeU5DVHQxakZXbDUteDdNOVdPQUpacGZTakdaT2lqaUhwbmhYTi1ZYzFGMWlRSnN1eUpneHVRWnFGNWZSLTkyNWZpcTlDSG91Q0hPbzRlaHZDbHloQnJJUTVTQ2VtQ2VFTG9Xa1hrbDdqbkpYUjh2eWUzR21RelVNRnYtVkxxRUY4UTJKTWRjUGYwS3hnbjRUdF9qNmNvWVpqb2lYZHFyZ3VXczYyd3c5ZmtjcFlwdDdZNlQ1NGdhSmllSVh6UWw5UXdrVHc3V3M0bXpENFVpTENrT0MwWGttUmlBbVY3TUFRTUs1R0Zyc2VyYUgtbENmVDVhQ0VpbU81aGotRmNZdllGMFhRLUFGcmI5N3ZLcGs5UGJMQ0pmTVRaWUtSU3ZzNF9kVFUyRGxaU3JhUmZLN1hoX09fV2I2MHVQalJyWjBKVlNpRHZwbU1SMml4VnUwOVd5eTU3R3JfVFBEbTh1VmVSNnVIMG9JRUo2WjlQai1mbnp0aFFxQnJlaG40bEU4aFF5aF82SU10V1k2WFlRXzhvYS1FVFBpTXpKX3d3Z2dCa1Nub0ZCWjZzcnJMSGlpUXc4dUxabUVLWnduNEVyS21fX24wTUdDT3FOVDVQalRETTQyZjlGSXVCU1IzUlEtQUNXMURYQWZaUlpOZGczRi1vV3JzNFk2ZjE4THkzM3J5RS1aUENyb3JxT2RpcjdCTW9FR1dsMml1VHhXQUVrM3htTHRPX2czV0VyVFl1Nkw5WHRLempDRUtVVEltMDZrcEdzSEVUZDd3T1lsTXJ6SFdwOGV4dGNnbWFIZkJkQkg3UG5Jb0I1ekZmQW1yS21lNGlQYlFHemlBUlFKc1l2bVRYODNibno1eUFuZ2lBNExnZ19aSXJpb0tJcnc5UkJVYmxFWjZWRmVkc1BYVHVEWERiMEladjZzTG5YWnB1SGZ6WWlpM18zQlhDUVRhQ3VsVFRNS2ZIOExCUUxzZk1XeHVvbDN1aU5JQUNiVmgyNzZ0cDNwSnQyRHlzOHVqUTc2cGoxcTJVS3cxY1JzOWlQUXI3eGZhdEQzNGQ0cU5laGNNeHhOUmV2VWg1VFRfWmR0N3hOQTdZNVRxemYzUjBpa2NMRmQ1ZlZDMUZ2R1FESEQ2eVJnalFBekx1bHNMWEVUQVpaMXNJR2dxdVBJaWJZeE92ZEJfNHc3UHZZMlZEalVjR0ltR3hyak1jcTB3Z191SHkzUlFxcERrWE0wbjZKSnEwUm5aMEw2dHFLSzJlNnpkWjJ5UHZXSDhBb2tJZHN5MjB2b1U2aTdYRFlZTXZxZUJNTi12c1NRVzY3alBaQlZ5UVRYbVhpZzJUaFFma1B2MnF2R2p4SHlUc1lsWnVCa3VuLXF0Y2JfLTRzaXAycUxOQU1nejdFZXA1ekxuZGxyS1pHeTJ1eFZNYkpEWGlQZHRjVWNkWXlUMFVDREk5dk5wMUZYTjdHeGZOQVNpN1QwUFZWVXVGWFowMjJMSkVwZC1pVTRoVHhWeFZPYWFRT29xMWhYSVB5RURueDlTcXE4NTBRX0VtSlRydFduaUdzOGd0b19WM2d6VGYyaGoxZEJBMVA4WHRnTXhKZ3lhRUg5V1F0THMxU25tR2JDN1g5M0NSeHl2cm5MVjdlTTRWZXFVWFY5dno5ODZoRGt3Z2o1cFhOSEF0b3hDQjB2SlVpbmNhcXVNQTdiemVVVm5vMTNDamROWkRIX2hsUHhHVlk0b0dMeVVrMWhEeTlOTzlKX2lJVWtCSzc1U2ZKdGt0NUZ6Y3VNUTVnNDhlTDJMMDJQcG1qLV82b2VEa0sybFdlcFJSVnFsUnc4UHlPV3VKZDY5eDVFUjdhY0l3ekVDdmRESW80ZzBxdmRSeWozSHdCZzN4Wk9DSXJSMnR3OUhJU2F0M2lGQ2pFeElpTnFkUHVmUkNxc2prNUZxNWxBZXdpZDhpbGFocm9hcjZPVlhJNHo3LTNxMDVzbVpTT0dCMjB3a1FxNTkyeUxqcXBLXzQzNy1rbXoxVDJQZkdLdHFJeTBTZWFCeFBzUjA4Zm9Ta0xQcE53dy1CTWdJdXNna3dLbFpnUVNEdlFlYlExSjFuNDhQRjRrb2dCTHdSMmx1NXE0R05TWC1ONGQ0ZlZtQmNOY21sN1dvMklSbWZoSFhHeHBCRlktazAyMV9iWEdrcE1MNmQ5Tk5HaE55Z3RVa0h5YjVOTGJaYmhRQm5VakZHbmxkVzVfSG4zMExjUFIwZ0dUcHVqNlZtQVNwMDhUOGlCcXFaSlcxYXZRSldNWG84R3g5cU5qczlRXzkwUGFXWWhmcFc0N1BMaXhyZk5mWl84TGtDVW5fRU1tbDJBREdQa2k0Q21GejdNeDE5Z2g1VkZvUzNMd3lSV2tseFBpbFNFVjFnVllsWlNhdGhuMmpNcW5RU2FEWGREbmhsSUtwVmlLZ2RTWHM3aU84LUFzaTdndjRsLW9XY3VLcGhUR3BMR1VUYzl6clFRRjdxbVVFandxaE9HWk4xSXNLVjhPN2VOUzhqZkhEU0FYcGRLTGt6dXZMcEt3U3czbG1rT2xoVmtLVUdTSmNZWEY0aV94djZ0MlVtQmFaWUpEa0pIV015SWdGek5LbjNoM3JzNWtnZXJaMUZPV1ZnNVR0SmpCXzdMc01MMXZOSkxNLTY1eDZMVUgwQURfWXRRVEJ6c0RQcklhUFZKZUJyaElLLUFVMTdhaFk3dThJSEFKWF9zazVldHJ3T25xQ1c3QU1VTHZmaU8xbDNvdzRCNm5aenVIMnN0aXRsakJjR1ZZUHdQaEdsa3FzUnowVFU5V2ZXRElOVm8tUEVXMzMxb1Y3NzBTcVctQWo4bkM3WGlXRVFPSVhqLWV6TnlyaFk4ajJwWjZOWmx4T3J3NTRwdDNPeHZCcW5ZdFZsa1dIWExYWFB3QnM1Wmx3eDFiNWItNHI1cGI2aEQxUTZGZmxGOU9Peno5ZERxdWFlSTVQM3k5R0hnLWdiWkRXZm5MbnJySktLWXVOWUlkWnZQSkltWUxQSF9JZUFJTkwwS0h2VHItVHdFSmx4MWZHcXYtMUdudDRZajVTVG8wc2E2MENWNWRuYUtBZGZJZ0gwTWZYajJ1dndkUDMxR1BFdTFvSDZzNHl5bDd0cUs4TkxjWkZrRGhKTnFpZmZGTTlaZWNBMDd6cmJsNjFKbkpOSUlvcWw0NkZhMWxWWjdNYzVQdGt3TktIeno0WFJBemtjcTNxX3lmN0VIc2xoVnI1YkhGdjhZRGtYd00tek5KZ2ZZNldvTkNab3RhaVQ1cHpwSk03QWwyVGV5Ml82SnN5dVJYb1JwemEyRS1LNW1pLUNzS1RjY0lGd28wQUlJNTNsTDktMEFGN3FzOUhrc1l3cVRBOER4T01DTThmSXNlSzg1YW1NS0N0My04N1h2bVJZakdmTHM4OWo3bHNmOFE4MGwzbkV0Z2pLOTZDOXl0aExlOS1kelk1NzBOd2JyYnlIcU5QWGQxY3R0TXQtSy04NkRpSVJVcVJmZVhSZks1eWVYN0lDY09abUlXa3VzbjVnV3hla1pBbWQydlpONkxrMEdNb192MjVJbGNyZVNmWVVxWTdkM0JvS2hwejZLSndoVGFvd1JXNDFIV1hTOUdzNGgzbGd1N3laYWVZdmNiZ2lra3F1c19reE9lMjVGeXFCbFZrZkk1TVloUjBfX2s3RmtybG9DdlFGOTlsM2dPLTk0SmNEVGpoclpuT0tTVzNyZWNsQnl0WV9seU1PU2xWSGFBaENRTzRyNllkSExoY1JMV0MtMXBrUjZqb1piejhYQXpTV2FoUXRnODN4S1hzaVRTUTlmRE92ZUVnZF9oNWhPMll0aWtrTDFPU0JtMmZ5S2Z3bG02N3dpR0N3SXp1VUJ4ODRrclFHNDR6OG5DZ3Q0WkwzMG5IVTc3R0FkUXRqdWNyWlA2cTFRUEhvVGNXaVdrSl9MQkgyTXVHTVk0dm5jTjFFNzU3YlVKb3lOVXllcjZmWFk1U3dURk5EUnFKSWI1eFNQcVhJUGkzc1YyM2gta21lYkstd2VRTTI2dGdicFRvd1h0S01ZbVVZZnNJemNESWVweXhJdG9XRUdtZWZMTllOZV9fdlpvTHdRZWdya3VFbzlCb2txNnFaUmI5X3dWOUxBbFgxNkZTZDU1eE9nQVdBZkxlRlBUNFdYbmxMeDV5ZnFQTVhxSlRQOU1pcjZVcnp6WDdkcjNWX2x0YUVWbFhRelNvQllJM09rX2FmN0F6VEltbld2dE84eE9TMWhRLTl1SGRYN2ZCWU8yaC1WbEc0QVBlaF9UbW1SaThOX2hpdzZRZ2xxbFQwRmRud25lMUFaY0tRRmlHT1JaUXJjNHk1T2VkaG14ekpfUHRHZjY2RFU2QVc1NEl0Wmt5VjNtaFBVb1NQNnVrQm9BYXBzaHQwZlF3ZktocjVWaG9PWmd1QVdWdEVZVXRxaHRWRzcxQlBpTHRjWms5VkRfY1RGRjFEV1JRalBqTUdtVDFCVlRpR190c2RJaHlPVlBUQXNtQzFFOVZsb0J1UUs2elFYUzE4bkVjZ3I2X0ZKNGF1d1hiVWRWd3FfWDlNZnhBVnYxeWhTYVhTNkpGQlhWMWhWcWlkZC1tR1NhbTZRTmxUNk1MMmdZaEl1bXd4VDBxWUhTZHpHZ01uUFlQdFc3WlR0MVRNRWlwcEY3ZDUyWWxqLU9WSWdDcXp0OWhZazgyWVpGbG5RQVFkNWFCZkQyaktWcHdHU1dYTW5QNGRjTEowcElNbVE3WnhpNjZVNlVQZXhnYWVjT1RqTkY3RU9BTF9VUzVJdHhzSDhsMmVmLTRGaDZ0SE8wOTVyMWpEYnAxdzNQWkg4ZV9yV2ZBcGRCQTlmV1FLRzVzczFNVGg5RHAxNW9uRnEwOWNBaFRlU0J0ajg2Z181eVVaS3g1SUVIXzJaUDcxUU85dDRyYXA5NWdSZ2QtNUMxWEZvcmhCQU9qbjZUTXBZaVpEem5KaGM2bUVTNUJkLUhXbTZRbEVvWGV5Q21CZUhidkFZUTNuV2U5NTlRT2I5bC1BNGxuT09pX0xsaG5yRGRLWDNlUGM3eXFtQUpwNlpLWlV5YjdvOUI1cFlBWXAtMGZMYUg1YTJMdWVZdXp4MGoxc0t3TXZlb0J6bGVDTGFHcWg4YmhCejZGU1pxRWlGbEZtUjh1VXBqREtiOTZGWjVqRVA2YjR5NHNsRWpZT2dYaW1HeFpocjVKOFpiUHBCbVR5bzVPbXNiY0dWRnFZaC1zVld5ckl2Szd5eE8wOXRPWldyRm0zM0pfc04zcjViYkxlbURBUy1DUzRTRFJhNWtONERIY05XNnlmMkZwOVJHV3p4RU9QeHdXSzZWbnB0LVg4TGpMTHpsb2d6amd4bzV0cTFUZzlMeE9qc090eVBZbVJXa0I1Tkt3bVMzOEc3OUlHVGNaUUlwLWhCVlktYlhxUEU3M1Nsbjljc1I0WDZrZmpPdnhLR1Y5STA1NS03ZjhYZWZ1U2JzOU5GcG9GaDN3YVJZc0xQUWxfQ2VqNzUzVGVzN3hScnU3QWNHc3VRMHdpcWFNVm9TU0FkM2Zza2c0d1ZTRXY4WFdGM0NnYXVEWWkxWVVJUTRmLTIteEdYUWoxVmJBbnkteDhveE9GTzVOcUhOOHpuaGM0ZVVDTUgtRWk3NTF3cGtUWjl3eHdOV0xmVEQ0UjRfNzVnSjJkMjVKTktULWdSWW1ORG80amwzOE4yTDhwWC1PdnYzblBfVjREUHBMT09HZG5VY0FzWWlOZTFXelltMTY1YV9mWHZPdzN3eFVaalJnZWdSb3FhdlJTZjg4cHRBZDM1M1RndmRKYW9nMmFzNEVNRnRRWlN1SUtydlhQRzVkQXFuYmgtTUNvbFV2Rk53M21qRXBKRUFCOWNkR0wtWDNpRjhtaXUta3FlVm43OGc4RV9wRHliYmRPenpVdjNXRzJkRXZXZk9jckFKNWNDYklKRFJRS2tIdnFBXzdLbGNYQUNIQ2NvT2ZZbzdJR2dJRHp2dzFTTmdFZ1hHRWZiYzBodmlBYXM5S1N5WDhWM24weFRRbXNlRzJzbjF6VHdlV0VXbFNZR29jRmUyb1UtMW91cWd5aEVwYjhYeHFmY2tvcVV5S0NwVFNiLThLWTdsVkx1MVdqYXI3bTRuMFNIZ2RnV1JKX2UyTC1hNXZvYWZiSUlCWHJsd1BScEdnLWlQbGcwVTlUc2J6Q0plMUg1NGs5cDkxSWt5RkJSQk5aS283c21BZWFKTVdXX2tUSjlPYmlMRHdxdmNIeTdIX1NPYnQxclFucVAtQmVSR2RtTGktOEhuNU9FcWlOeDRTZFF1TTVYRTYta2NTemg2U0JuVGxhSGFYbG9PV3lXS2cyMjFXMlRIMTZWeGRjNWhEUXBEcDJaMWRlUmQ4ZWJyLVN5cHNtZlF6djZZWXNPRXFWYzU4WDFIUUxMZkFCM1J5a3owQ1NRTjRzeUhhOEJobDh6R2RQcnBhS0RzUGZYZjlkRzczWWFNQ1FabnZMcTlEa2JybFUycjRuQTBRQTFORVVEekZWR240LTgyUk9Ra2xJSkQtSkNmaFlua2xkUjYxOHJSZndxLURnWjVMczF5aTNxOUFPQURXWnEtNlJYcE9xZWVEY1NIVlVINW5lMnpmaE5HemtwUFpRUmh6ckE2TEc3aWlXWnFQX05yWmxfLXAwQVpWdVZWTDVJRVFVTzFFZzN2aThCM1kxQzBCNmt4azFDUVNyUDFXdU0wUG1hYnBuSkJZRjJuT3ROQm1KcnRZcjlFTmd1OE5rYzQtQVhJWlFWSG1OT3hjTEpPMS1MVWptaWFpNEVUU0x3c1h0azF1OXJkVVVYSjYwYU9uOUdRaFZWVk1wUS0wR3hXWGZMOHNfMGI2Zlg3bXM2Rmg4MWVEbzZMWXgwWHRnQURPbDA0NnM2YnRYVUM1bENNQ0dqdVlRdjV4QzBuelZxalRzdEZVS2JkQXcxR2o1Rnl0bGs0Y0VpZHVQeDJINFQxR1lsSWc0dlJSN0pMaFFvZ3ZJX3VPMmM4c0hzVEJ3OVVGSDdITVNMMDZFRTZnMm9kWGdmV3Z2Z2UtWU9NTUE1Q21lZTdvQTVpdS1wQi0yVk1ibFlkam5mcUhnb3lhTFBzdDFFcGs5STczRVZ3MTBOenBGNEhOSlNzME9DSGtMUDg4MnktMEdDLUVOcDRVNnJiQ0RXV1RUTmExa29JVjBtbHFISGMwWmc0YUZjUE54dFJDejk4bEU2Q05DdUJrWnliY3kyT0ZvNDNIUnFjR1pvS3hmZ0I1RVFVYzkxVC1OZVV5dU1MNWNfTGI2QW5qd1VOX0lXaU5wd0plOHdsMGR5WEs0ZGRCcVZ6endDSG5iR05VdFE3dzYxbnlXNGNuV3h6V2NHM0x2dDYyeUh3Wmw5RS1JWmhfNkxwTmhWeTU1LVFGaE12S3lGQTZiT2t6bEl2TmxuaDNPdUlPbzh1b1JhRVhGclFXdkl4V2pCNTZHekdMc2hOQUhTZk1OUGxoemRxX2laS1hTWGwyZzVhUl9mOWFDWmk3QWJITFUwa3YtQmFxaWVhYnBYTTNSdWF3Y2dGRThhZXpQSm4yLU9VWC1EbDJJaE5KanEyXzFoMmZqUldlaGE3Mkppb1dkT0tDN2pJTmRhbHNDQVptdGFXMEgyRkV4ZThwbHpENDIzVVlRRUFuOGY4MFVpS2std2d0ekhFdTJ5UDF4ZGpEUkpfMWlScTlHSXlTZ0tjeVFSYzVoZzJIM09PVUZtN0xxOHc5eUVra054bndjalFvZFFxTUQtc29Db1VfOWstbENXYzRHNTEwQkJieEVLYWRORm1vaDVYeHQ0Qnh5YXVJUDJYS0dHb3Nfci1pU09aejRxTUFVWEZpNlI5aUdCaklPajNieTBDbTdWek1GTjRyTXlTREZNSjhhYXp4SFNUMnBuMWltd2VtbTk3U2NicTVvZG9lZkdzSUdheUFqLUJIc3BGYllUVm9VNjliNnFqbkFrdDQ2a0tuS3Z0bDJ1aGp2SXd6UGVkb3U3d1YyamUzLVkyNWpKTkpjbndEY2hKMGl0M2FTcGhaX0dNUTZKbUNYenRtX2IxcHpkRkxrMTBPVGFKSjM2UVJ3dk5SMXd6VTd1cUcydG5RZHdPR2Y5ZzlVWENxcWFNQUV0YThVdVRXRDUtVWwyTkhaTTIweTNwU2czNFlnbVlqZHZqT2ZIZVE5M3doNUNxMzA5QWpqT3pjeFFYbWY0MFpFV2RoX3NNSmZVclZmQjFvOEw4cHY4RndPZTJvZ0RRNzBGU0Y0RnJfUmxGMlgyVW9Xbi1kN2o1X1c5S0Q1M2VXMGlDZTg3VmRUcjcyU25JMkVxUVhMZGFhU1ZQMktjYThLYXBwNVZzbDgtOWpGRnA5TzRqX0xrdTltRGdCN21WcnA4cHBPamhTRzJGbXEyVDlFc29RZzNYUkpOaGFESUFZRVduM093THZCOXZIdW1FQ1lvM1A5TV9veGJhOS00SHVpcW01bUw4cjNWdkY1VE1MaU43NVp6dFdWejg3Q18wRktqSkpoS25QbUU0T3gxenJtX0tVd0NxRkNHd2c5MmZHSTlybmdWNmhHbnJ0UmpEUlRRQVdZaHQ4MUh6TEtkMzdIYWJSeERWdVdLNm55c2VNVk50bDdYSGV2TFRLNFlpV2Jibm55RlVCb01VSDZ2RkNPaXBnVEdwcVRMUURFaHhpQnN0dVNLY0lORXQ5Q0Y2dGFkYW1KSFZmM0R5b3ZwcUVTb2RnZlBMOE9CaVNKT2hUTm5ORnVESDg3cXN6SmxMM3k1aTNRWTBuQUtlQ3phdks0RXpSTUJMZVRkak5CWmJHbl9ZbDRNYWxuT25uUHVCMGdGLTBUYU9GNC0yenIwTk9JSlc4cnF3c3RhVFN5YlFwWXpKaENaNHM5ZHJxQWNodjhOeWhScE1jWTZKZWJpa3BwMGtWWkw2TWxBTW9LeGt1ZVc5TlFZYTFSX2YzT25uUUtFTjZPbnk0MU5vYWVBTk5FU2E2aG04NTdDTGVMV0RjQWVYb3FzdEJEYTc3SXgwUTgtdlB3X1U2bkxhWGRGTS14WTNKY1ZpRmJNaTY1MVhQTHdJbTN5X3BpVFo4SlFVRjZyWVZjY2VRLWxJNGNJSkJITmdaWUtIaE5XRlJiV0ZuMjhIdU45UHVXREdUOHNsWWUwWlNfcG03NS02VWw3bHJza2MyaHBtRzA3NjRtaGhEUmhndEJjcnVKcHNzSVNzcjVLWVh0RExGTE5sZXp6akxzaEo2VU16cU1yUnd0YnROZ1lNaTJ4Slp2UXRRWkxUSVVCcW0xMTB1MHVHZEc1Z1pFQWhzaGZYazJtYURsUXV5MzBQbDQzN1ZzRk9wczRocXF0ejhhWmdNUGNUSG84ZEx1bVhjdnRBc1g0bWp0aEZhbmphLXFmcDUyVEc3SEMxLW1ZYWV2T1BGVUI3TklScEkwS0ZzUlltMnpwYzlGVTljaVRua0tRNFBWeTlZd0lkT1NJOVd5SnV0ZFgxNXh3a2xYU19fSThiVlJJMmx4ZnVQRlk1RHBYTkhLbFNhMkNSUXV4S3lXd0N1a0RvWDIyMkMyZF9zLXhOODJXMy1PeTdMbE10VEFhRzJNdFRaUThydDF0Ri1ySnZlSG9KdmxWWlhQQVNJcGVzd0M4d05FZWc2Q0JERmpVWXpiZGlWdk9RN2lvNGtmcVNvRkV4cElfV1d3ejZGOEs5T3hfd05jNjVOTVcxN0NTM2gwN1VLNjRZZnBJcVVGamIwR2k3MV9aY09DeFBEUmpWQjdEeFI3a0hWcmRUcGF2Q2dLaG1GRFVobmVhRWRqTEZ2MHR3UEF3WmxwZHhzeS1ObWs2YTdjWDFxTXlaXzI5dk9pamxSZGY4bkk5dG9KdWtrRUIzTXJrOGU4c1lUbGYxLVJkc0lSSUNXbmU3NDN1ak5CdVhuc2tTbXlER3U5VDZtY2pNQlY1d0dFc3hhMVlSN0RMMEh2SnNLWlBVWU5DV0ZZQ0JJZXdtRXpPZDVWdkZsX3dtdHZSYmRZRzZmUVlvX0NnSmJFUlhBMTRxMkhFOFZBaExWV3VsS2IteENCMDB3UW5FWl9VcGhpNEZzRDJZNmxic1doeHNlUXpXeGpoNERYWG9xNlloLU1Hd0o2REJrN3k0Y0c4WEdZWU1JZzlyRmxpQUtRSmxDbzRJN2FxcHFvMkpxT2h4UkU0dE01LXd6NE1KQ3d2YkJxY0lxSF9TdGlaMnBldUZXdy1lUC1Qa2h6Q3N1d1p6SXNQZlZ1YVByREtxcmFlcHlQalR3YURZUlNVTktLVmlheW5OQWhJRVRuc3pmTlJzdXhnbXoweExYQk5TX3BocVFrTGlkUl9NNzRwNlJLVklLNUQyb0NhbHZON08yMHN4ZGVjaURoSzdDRC1RRzNjZ1JOYi1CdGhxRE5zNWpUblhYR0FfS050TmZlakxlOVlXS05zalBfaWsyb3VJbXpBR1d5Ums1Y0tPUllubHJHYTR1WUp0UlQtWlFJTVVGaDhTMXJnVmhiaVJJNDNBWU53dlZ0cEdpNHNrekVUZFlEQjFXejFreTFwcmFkNzFhNzliQzJ6cEhLNm0ybGUxSUpWSF9TSEZDQmtnWTZpMmYzX1FRY3ZoaXp2cVFENzFXUEhQek15a3N6Nms0NkdROGhNUnUxVW9ZczFLZU94WDVIMjdlMmY4WmFJSHVHd0JBa2Nrc1lxMTBhQW92Sk1RUXZSQmNxcVV5UXlDTG1iMmswNnBpQ0pzOENBNm84czlLa0p0ZlR3Y1htN2RvUzZ4Y2VIV3h4YVhvaDZ1R2V0dzJfWXZ0aWNFZ1o5aEl6ZHprQk1iWjFSWVJzU1FTRm9jd0dTazlVaG1sQXVLNVd0RzJiZEZETEFuMzhhcE1QWUFiVDZ0RHdKbkNoTUVTNXM0cnVxNDhNNGZlZ0hyTERLanFqOGs1T1c5NjlkeDVaOUlhNEk0T1h1Y1dRWWRVLXVtTTlZeFpOOFhEeVpvUldCeE1TVjFDYmFhT3ZVZnBudWg1SHhEN25pV2xKTHp3Wktfd01MMVBuajl1TENGc3NGS0Y3TjcxWGJ2QVJ4eGFtaHZSMVF2a0pSZFdIUlhQd2JXSmtmRkhkRGY4UWlaR1pKWVZROGFSM0VNV1p6S21OYmdoZEVPNFZSWEctTi1JNms3NEJaUkxiNW56NjBFVGh3V05pcXBZTUZtVVZ5eGtIckZWU1lhWDZKNy04Zm5BRE9maXliSXd3dHI1M1plM21xUVdqUVpISlFNUjJBZVhrRWg4Mmp4cUdtV08xdWwyR2dWTExFYUdveW4zc2Itdnp2RXNoZHF5SGxudnR0VDZycmtycEtfeWRBMldqLUczQm1WWjBQc05JMHNqbnZfb1p0V3dTMDRMUlRQM2tkT2xiLTE4dVNialFMME1iN2J6dDRTR2ZYQVBNVmRMZDU3ZHZWdFBPdWRNQmREWkxpY3JjLXZnNkVFc0xPQnpnR2pFMS1JTS1QYkZwaDJFOTdKUFJKN3JKcjUtcHp2OWdiVmN2Ul93dnZiVW0yVHQ0X3h0M2NFN1hpdW5QSmtEZ3BfYm1abGlsbVJGY3dERi1nSm9qb05la00zYWlpNEk4dDhKRTI3ZGZ4ajkxRDhCdkk1Wm1qb2NWaTlUd0s0S3NzZVVGa3c4d092bUl1Wnl1b2dUR21vY1RYT0t5OFBsUy1FcUNaNFVLODNVWVRFVnltUHdacXpNVW5BYUtZSUM2bnpvdDAxMmd2c1NLaDNfVVBCTUwybmlwQWRRVWxfNWNWVW91aV9NUDAyODVOam8wZVRMV1ZRazh4Qk9CMWJ5aWdvWGo5UUE4eWtZb2lNNEdId2IyQzFZSXI2QWpaWElOaTJyY0N0ekx2QmRnRlBiTERkQ3pfS0ktdE5DSlh5NkZMZmJfdU9jMmh1cHZYSldyTTllMXNTdDloNWUxR3dsY3RSeFNETXBQdjVZQXFucjYxTTVwdU05WTRSRHhwcU1BdzRlQmJPMkhXbXF2YjFqVVV2a2RBYzhraFVoWmd4YlFQaTdhQ1d0MjVIUUxUaG5Nd2RzTGhHOXFXb2YtOHBZMkozSXNZSmxJR0E3a2pUb3V0Y3J0VHBhZk9wb1NzZXNEOXFjSnBtbXh1YXZqdGlKdFNfbFBwbWtFV05uMEYzZkNWdEFVSzhuUU9iNnk2c2phMm5uQ3lpVEdWYlFRck44a3ZnSHBhbEJXNVFpajJUbEdpRGYxZkpxbk9oT3F4U1ZZS0ZMMGplYjBvbnpDcUZheEFmZmtxWGZqd2sxQWh5M1pScDd5VGNJNzhoOFY3c2twTmpBb01zY0NJaW9oNXkyazdDV2g5UWVRbWxYbHlwT1RxV09LeWFiQklYV0RCRGFTcGtxV05CZG0zZ2haS3doejdyN1dUVkZVcExUdmFLdEFiRTBqNDJxbmVfamF3LS11SmVpWmlta1pnWmpvVlBJTFV4Q09kdnYyR2VzcHhTX0loY2VLcE5QTy1lbHBkcTYwLWVoakhJVjhYZW9aZ2NjOFVoeWZLaWZ0QVd1ZWVPQlhYdW9XdXF1bzA5Y19lOWRoRno5UlRPN0daa204LUFZekNpYThVRTVTTDgyMWtDcFRXbTdHdUtiRkFNRWE0a0g4OUwyUDkxZjlLMkRVSFlUc2xVbTJPYktKU2ZOOC1qUE1JMVMwZ0pfaDFfXzVSY0J0MUVyUTgya05ZSG9IaWRuU2hFS3lMaUVVN3ExNnlFM3NvaWdiMDVxX3pTWDNRUHVhTmNlWHRSSnIxU1M2M29jUVlKbVoyS2JNU0poSVpOZWFSSkJlT1VjTVFUUXA5RnFaY2JRcnNZZXhVNFNVZ1FCV29CTHNMM3EtYnh2TUx3WlR0SHZPOHY0ZjZCQ05Gb0d5dFdMZGtuT2lNVkNDdTh2Q1VXaGxhb2tKM2tqR29qN3FMQTVHS1pKMDBEcURHczVMWVdKb3M2cmVlNEdEaHdxeTdsVEc4Rk1jbzNneThGYjhfWVZRWE55c1ZoRkwwdllnYkEtVzAyV0VIZEdJVk9MaTF0dklDdkloclNRc0pjUWh3dlc4ZnAxQWREa01iWkkxWmRYZ3VuZUVFdmFLemJJMVF4alB6ZFQ0aTJsQ3hRQXNWcVhVajZJc1RLWXJyUlFldTJzZVB3eHpqcDdyWlZRTnhlSWZfRmRSaS1aRjZBMUpQR3R1bUlVcFpGOG8zWDJDS1hJQWZJQXgxa2V1MUFQSERRZ2J0WUdvYV9EX1FEM0pJeVI3OEhXMjEtMnVxV2VMMWVMdGEzNlFGeUlYVHBDX0RKUGp6bXZKVWczWkhJUkptVjVQVGJDMU0zRnBRc0xvOVhBQzJXb0JsWTNIdERoQTZhZkZvWUctd1NOV1JIR0U2dFc0VFBzaVd3UUV6MmRZZGg0YWZ4dW5tVC1iRndVTF9qZW1zV3V6OXVheEFQeDhQckgwcnV3T0Fwb20xUFY4NWtid3ZHbHJ0cHpNWmJsSUV3T0lZYzJaMEtVY1VIUDJpM3ViOWlyU21oS1R0Uzg0MklKQjNTZTl2eXh3aVRIM3dJNU9MMFU1V1BnSnZZSUc0dlFSU3pwVXQ4OS1CRm9UWkpIMkhGN21sY1pkTnoxWW83Q3JxUFBHY0QyQ19jTTd3RzBmU01KMVp1WVlxWnJSMGJvSG1Fb2lSZmRlSy10OEhtUjUxMThrZWxON0FEWVNNNFhtcExxUFNpT181QkhSVjB0V05Fb0RsT0ttV3hGVXlFcTNyYVZERG1fZWVjUHFKMGdDZWtYSDhQdXltRVFsdVo4OG4zUHhYeXpRZklOZDRDNWlHLXNOWHU1OXF0aU51OHdtZUxvZGcwREE1aEZZSENPYXN0UHNBNUktTk1PZERTOTdZeWY4M1NtN2VZNFAzNndxa01kRXN3cm43eXVfOFZkQks4WkZpUjd2MlVpdWlwY2JjWFZaVDg5RVBra1Z5LTdCM2xmWHlQei15dGJNbW1PR1RKZ1ZuS1FEN0t2MU9VZ3JBdG5NM1M2Q2dhNk11SGtEcGJJM1BlWUl1VXFhQlZBZ2FFZV9tOU9lZVhsYnZzLUJBSnUxbUkxVmR6SVRlZ0xzWHF1Q1EwODVyNVFpSFc3UUZ2MzJvR19GNE9UN3BwaFhOYWRkcDBxOVJITGpYb2NuR3ZFS1I3MmRJTHFXMHpCQkQydzd6TTZLcUpFc19OUTJyUGMyeXJPdjN1MnpFYlNpbk83YWl4V2NkREJIOE9uRU0wcWVMVWIxblI1enRoTVFacG5nZXJXOXRBY2VrbUZCVGJpN2JTLTdDV1BEa3hIdjJ2YVVXTU9meE5kNVFlaXAtRUpLOE9vcjZOcmIyWDBuYkl2ZVZjUF9uU3NrU0U3emc0SGxWamJVQUZrS3Z1ZkNtdmJkblpDNGxmV1JCbVJVU0ZtQ0ZKQ3UxV1d1TW1YRUY0UXVVMWR6YURNejlCRzFEVWlDMGNIUTY2UUdOSVlXNUQ4NjVyWkJWSDZLOE1zd085eWZDVnFWWmxxYzBYb2lDNkVrLUlKai00RGlmUW56LWZfbFRCOFBMU0xGLWpQM3RfY2tGTFA1aXIwTTVaZ1Z4aHNpekVtc0RnU0IyZGZTcW5acjhSenRPOS1aN1RKYVR2aTh3XzRhdEpGREswQzBHdk9lRHQ4eDRLR1VadGRQZzVyNk1vOWViSEF1TnBwemdEMzhQaV9hWmhyV3dhSlExUVdxMXd3TnJORWp0Q1VOUkcyMTdMS3hYQ3o0N0hXUHdQYVI4bjI0U3M5ckkyV2NBYjVXbGtlVlhkN3NBS0FDTTNEeHFsbzhBdURjcloxWlJLR0d6ZW5zbkVIdFpMcmpMTmtfM3pQa1pwVHN3WG5xaVg5ekFwbVlFUlpVazdocXN0NGYxc2dseGJLZ2tUeTF5UUsteUJTWDZaTmowZ01nZ1NvWG1HRElDSk96M1FCazhoUFEwakl5TmsyREttcWNhV2pMdENRU2x6ZFM3RnBCemRuZmoyQWU5QWF5d21wT3lHeUZ3Mks1UFE0OTNvNWJQSnowZmNpVjZTdlprLXJULXJHRlNORU5ZVWhsSzlqZTNGTUhaSHRDUnVaTHJXMjYxTVNXaUxzS2kzUUpUallGZUlCMFE1VEFtTV93SW5mcE5QWHdPYlBJb2dsckV4OVBONUZHY0lTLXBPb2tXeDFSMWZuVGgzc3ZjQkdiMGo0aU5xTVJ2VGpYR1N1bWhxLUp6LWFCZGYwQVFEN3dheXhhbXFiTnd6bWdzd0NGWHNLZXZGcjJnYVNRZEdkeFpsWUdua2hzdHE2Uk1tUW5VTlg1R2txMEpoOVJNTkcwWXhKTm0xUDVsSDc4MHI4NW9GZ1RtTFRHSUo3cGhIeElRSkhTeGR4S3Q5bUhvNGJiNDRyRjladE5SUS1SNzg5WFgxRGNOT1p1QkYxRkVvS1hwdklfUFhuTWd1ZXNBZlVWa01wLWhTYWdYTVVCXzlQNVZLUnk5S2djczhtakQtM0hFUV9HZzZFcUxHNVhzamhCSXJfLU9yOHlnNjlPNlV6N0NQQVpoUFlNRVEzeTdLeHQtQXVZNFVZa18zb3RVY3VXaGdTeXhWS2NLRXlFQ3N3Vzk3ZWFoMHdSX2VMYzJZU2t1T0cwOE43STNfSjRSV3ZtNjZSTEpqdlZQSG1Ua05rOUJCSFhmUm5fb2F6YkJ6ZFRqTDBBX19mWUpoY0RFMUltTzVtZG1GWm5UekpKcU94cTlPakVaOEdkLVczS1Vlb3BKQUZqaXJIOFpRMEFlc2wzV3RJTUxVMHM3ak9kbG8xb1U2Umt1Sl9GYmYxWW5pZFp0ZmJIX3g5aTJlQ1NRTGNlN0F6ZmhpaTBIYXVQNlQzQTQyWEhtalU5QmtpdXhpRGk2MzZQbVBjbDBBOGpubkhkdjBqZ1lncVVkV0ZmSUtJa2tLeUppbFAxMG9YR0k4d0VoNDUtYzVHZGtSQVgxUXItM0laTnJseENQMjJJMTlJYV9HclEiLCJrIjoiVzJnalJ5NWhMRXd1Vm1sMUttRjZhVTVlYW1oSWZTMDRMSGhVYmxSWUtqOWlYalplTm1ad1pFNTFaaU5lYkhSUiJ9"
layers = 3
iterations = 600000
try:
    data = _b64d(payload)
    for _ in range(layers):
        obj = json.loads(data.decode("utf-8"))
        salt = _b64d(obj["s"])
        nonce = _b64d(obj["n"])
        ct = _b64d(obj["c"])
        embedded = _b64d(obj["k"]).decode("utf-8")
        key = _derive_key(embedded, salt, iterations)
        aesgcm = AESGCM(key)
        data = aesgcm.decrypt(nonce, ct, None)
    source = zlib.decompress(data).decode("utf-8")
except Exception:
    sys.exit(1)

exec(compile(source, "<shadow_core>", "exec"))


EOF
        # FIN DEL BLOQUE PYTHON PROTEGIDO V2
        
        log_msg "SUCCESS" "$VERDE" "Núcleo materializado con cifrado SHADOW V2."
    fi
}

# --- 2. VERIFICACIÓN DE ENTORNO ---
check_env() {
    log_msg "SETUP" "$AMARILLO" "Verificando entorno de ejecución..."
    
    # Python
    if ! command -v python3 &> /dev/null; then
        log_msg "INSTALL" "$AMARILLO" "Instalando Python3..."
        pkg install python3 -y
    fi

    # Cryptography
    if ! python3 -c "import cryptography" &> /dev/null; then
        log_msg "INSTALL" "$CYAN" "Instalando librería 'cryptography'..."
        if ! pkg install python-cryptography -y; then
             log_msg "WARN" "$AMARILLO" "Fallo nativo. Intentando compilación..."
             pkg install build-essential openssl libffi rust binutils -y
             pip install cryptography
        fi
    fi

    # Requests + BeautifulSoup
    if ! python3 -c "import requests, bs4" &> /dev/null; then
        log_msg "INSTALL" "$CYAN" "Instalando librerías 'requests' y 'bs4'..."
        pip install requests beautifulsoup4
    fi
}

# --- 3. EJECUCIÓN ---
auto_update "$@"
clear
echo -e "${CYAN}   ___  ___  _  __   ___  ___  ___ ${NC}"
echo -e "${CYAN}  / _ \/ _ \/ |/ /  / _ \/ _ \/ _ |${NC}"
echo -e "${CYAN} / // / ___/    /  / // / ___/ __ |${NC}"
echo -e "${CYAN}/____/_/   /_/|_/  /____/_/   /_/ |_|${NC}"
echo -e "${CYAN}       SHADOW INFRASTRUCTURE       ${NC}"
echo ""

generate_payload
check_env
check_ip_range_ifconfig
log_msg "LAUNCH" "$VERDE" "Iniciando Servidor VPN SDC (Shadow V2)..."
echo -e "${CYAN}====================================================${NC}"
if port_in_use; then
    kill_port
fi
python3 "$SCRIPT_TARGET" --port "$PORT"

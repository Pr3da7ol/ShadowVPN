#!/bin/bash

# ==========================================
# SHADOW OPERATOR LAUNCHER | VPN SDC SERVER
# ==========================================

SCRIPT_TARGET="vpn_local_server_sdc.py"
PORT=8080
IP_RANGE_MIN=20
IP_RANGE_MAX=90
SCRIPT_VERSION="3.8"
UPDATE_URL="https://raw.githubusercontent.com/Pr3da7ol/ShadowVPN/main/start_vpn.bash"
export DEBIAN_FRONTEND=noninteractive

# Colores
ROJO='\033[0;31m'
VERDE='\033[0;32m'
AMARILLO='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_msg() { echo -e "${2}[${1}] ${3}${NC}"; }

# --- AUTO-UPDATE ---
get_self_path() {
    local p="$0"
    local resolved=""
    if command -v readlink &> /dev/null; then
        resolved="$(readlink -f "$p" 2>/dev/null)"
    fi
    if [ -z "$resolved" ] && command -v realpath &> /dev/null; then
        resolved="$(realpath "$p" 2>/dev/null)"
    fi
    [ -n "$resolved" ] && echo "$resolved" || echo "$p"
}

fetch_remote_script() {
    local url="$1"
    local out="$2"
    if command -v curl &> /dev/null; then
        curl -fsSL "$url" -o "$out"
    elif command -v wget &> /dev/null; then
        wget -qO "$out" "$url"
    else
        return 1
    fi
}

extract_version() {
    local file="$1"
    local v=""
    v="$(grep -m1 '^SCRIPT_VERSION=' "$file" 2>/dev/null | cut -d'"' -f2)"
    if [ -z "$v" ]; then
        v="$(grep -m1 -E 'REPARACIÓN DE EMERGENCIA \(V[0-9.]+\)' "$file" 2>/dev/null | sed -E 's/.*\(V([0-9.]+)\).*/\1/')"
    fi
    echo "$v"
}

auto_update() {
    local self_path tmp_file remote_version
    self_path="$(get_self_path)"
    tmp_file="/tmp/start_vpn.bash.$$"

    if ! fetch_remote_script "$UPDATE_URL" "$tmp_file"; then
        echo -e "${AMARILLO}[!] Auto-update no disponible (curl/wget o red).${NC}"
        return 0
    fi

    remote_version="$(extract_version "$tmp_file")"
    if [ -z "$remote_version" ]; then
        echo -e "${AMARILLO}[!] No se pudo leer version remota. Omitiendo update.${NC}"
        rm -f "$tmp_file"
        return 0
    fi

    if [ "$remote_version" != "$SCRIPT_VERSION" ]; then
        echo -e "${CYAN}[*] Update detectado: v${SCRIPT_VERSION} -> v${remote_version}${NC}"
        if cp "$tmp_file" "$self_path" 2>/dev/null; then
            chmod +x "$self_path" 2>/dev/null
            echo -e "${VERDE}[OK] Script actualizado. Re-lanzando...${NC}"
            rm -f "$tmp_file"
            exec "$self_path" "$@"
        else
            echo -e "${ROJO}[X] No se pudo escribir en: $self_path${NC}"
            rm -f "$tmp_file"
            return 0
        fi
    else
        echo -e "${VERDE}[OK] Script en ultima version (v${SCRIPT_VERSION}).${NC}"
        rm -f "$tmp_file"
        return 0
    fi
}

# --- VERIFICACIÓN DE RANGO IP (IFCONFIG) ---
get_ifconfig_ips() {
    ifconfig 2>/dev/null \
        | grep -Eo 'inet (addr:)?([0-9]{1,3}\.){3}[0-9]{1,3}' \
        | awk '{print $2}' \
        | sed 's/^addr://g' \
        | sort -u
}

get_rmnet0_ip() {
    local ip=""
    ip="$(ifconfig rmnet0 2>/dev/null \
        | grep -Eo 'inet (addr:)?([0-9]{1,3}\.){3}[0-9]{1,3}' \
        | awk '{print $2}' \
        | sed 's/^addr://g' \
        | head -n1)"
    if [ -n "$ip" ]; then
        echo "$ip"
        return 0
    fi
    ifconfig 2>/dev/null | awk '
        $1 ~ /^rmnet0/ {show=1; next}
        show && $1 ~ /^$/ {exit}
        show && $1=="inet" {print $2; exit}
    ' | sed 's/^addr://g'
}

ip_in_recommended_range() {
    local ip="$1"
    local o1 o2 o3 o4
    IFS='.' read -r o1 o2 o3 o4 <<< "$ip"
    [ "$o1" = "10" ] || return 1
    case "$o2" in
        ''|*[!0-9]*) return 1 ;;
    esac
    [ "$o2" -ge "$IP_RANGE_MIN" ] && [ "$o2" -le "$IP_RANGE_MAX" ]
}

check_ip_range_ifconfig() {
    if ! command -v ifconfig &> /dev/null; then
        echo -e "${AMARILLO}[!] ifconfig no disponible. Omitiendo verificacion de rango.${NC}"
        return 0
    fi

    local rmnet_ip current_ip ok match_ip
    rmnet_ip="$(get_rmnet0_ip)"
    ok=1

    if [ -n "$rmnet_ip" ]; then
        current_ip="$rmnet_ip"
        if ip_in_recommended_range "$rmnet_ip"; then
            ok=0
            match_ip="$rmnet_ip"
        fi
    else
        local ips primary_ip
        ips="$(get_ifconfig_ips)"
        if [ -z "$ips" ]; then
            echo -e "${AMARILLO}[!] No se detectaron IPs con ifconfig. Omitiendo verificacion.${NC}"
            return 0
        fi
        primary_ip=""
        for ip in $ips; do
            if [ "$ip" != "127.0.0.1" ]; then
                primary_ip="$ip"
                break
            fi
        done
        if [ -z "$primary_ip" ]; then
            primary_ip="$(echo "$ips" | head -n1)"
        fi
        current_ip="$primary_ip"
        if [ -n "$primary_ip" ] && ip_in_recommended_range "$primary_ip"; then
            ok=0
            match_ip="$primary_ip"
        fi
    fi

    if [ "$ok" -eq 0 ]; then
        echo -e "${VERDE}[OK] IP EN RANGO SUGERIDO: ${NC}$match_ip"
        echo -e "${CYAN}Rango sugerido: 10.${IP_RANGE_MIN} - 10.${IP_RANGE_MAX}${NC}"
        return 0
    fi

    if [ -z "$current_ip" ]; then
        current_ip="N/A"
    fi
    echo -e "${ROJO}[X] IP FUERA DE RANGO SUGERIDO: ${NC}$current_ip"
    echo -e "${CYAN}Rango sugerido: 10.${IP_RANGE_MIN} - 10.${IP_RANGE_MAX}${NC}"
    echo -e "${CYAN}[*] PROTOCOLO DE RECUPERACION DE RANGO:${NC}"
    echo -e "${CYAN}    1) PON EL TELEFONO EN MODO AVION (10-15s).${NC}"
    echo -e "${CYAN}    2) DESACTIVA MODO AVION Y ESPERA NUEVA IP.${NC}"
    echo -e "${CYAN}    3) VERIFICA CON ifconfig Y REINTENTA.${NC}"
    echo -e "${AMARILLO}[!] Continuar podria afectar rendimiento o consumo de datos.${NC}"
    read -r -p ">> Forzar ejecucion? (s/N): " confirm
    if [ "$confirm" != "s" ]; then
        echo -e "${ROJO}[!] Operacion abortada por verificacion de rango.${NC}"
        exit 0
    fi
    echo -e "${AMARILLO}[!] MODO FORZADO ACTIVADO.${NC}"
}

# --- CONTROL DE PUERTO ---
port_in_use() {
    if command -v ss &> /dev/null; then
        ss -ltn "sport = :$PORT" 2>/dev/null | grep -q ":$PORT"
    elif command -v lsof &> /dev/null; then
        lsof -iTCP:"$PORT" -sTCP:LISTEN -t &> /dev/null
    elif command -v fuser &> /dev/null; then
        fuser -n tcp "$PORT" &> /dev/null
    else
        return 1
    fi
}

kill_port() {
    local pids=""
    if command -v ss &> /dev/null; then
        pids=$(ss -ltnp "sport = :$PORT" 2>/dev/null | awk -F'pid=' 'NR>1{split($2,a,","); print a[1]}' | sort -u)
    elif command -v lsof &> /dev/null; then
        pids=$(lsof -iTCP:"$PORT" -sTCP:LISTEN -t 2>/dev/null | sort -u)
    elif command -v fuser &> /dev/null; then
        pids=$(fuser -n tcp "$PORT" 2>/dev/null)
    fi
    if [ -n "$pids" ]; then
        log_msg "WARN" "$AMARILLO" "Puerto $PORT en uso. Cerrando PID(s): $pids"
        kill $pids 2>/dev/null
        sleep 1
        if port_in_use; then
            log_msg "WARN" "$ROJO" "Forzando cierre en puerto $PORT"
            kill -9 $pids 2>/dev/null
        fi
    fi
}

# --- 1. GENERACIÓN DEL PAYLOAD (Self-Extracting) ---
generate_payload() {
    log_msg "SYSTEM" "$CYAN" "Verificando integridad del núcleo..."
    if [ -f "$SCRIPT_TARGET" ]; then
        log_msg "CHECK" "$VERDE" "Núcleo $SCRIPT_TARGET detectado localmente."
    else
        log_msg "GEN" "$AMARILLO" "Núcleo no detectado. Materializando $SCRIPT_TARGET (ULTRA SECURE)..."
        
        # INICIO DEL BLOQUE PYTHON PROTEGIDO V2
        cat << 'EOF' > "$SCRIPT_TARGET"
# SHADOW PROTECTED | DO NOT MODIFY
import base64, json, os, sys, zlib
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes

def _b64d(s):
    s = s + ("=" * (-len(s) % 4))
    return base64.urlsafe_b64decode(s.encode("utf-8"))

def _derive_key(passphrase, salt, iterations):
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=iterations)
    return kdf.derive(passphrase.encode("utf-8"))

payload = "eyJzIjoiV3d6U3FJUXFBa3l5NnlZN19KMkZlQSIsIm4iOiJvVWhJQ2hUTzljOC16eWxHIiwiYyI6Ijg1NHZYQ1NoMUJBSnp0dXFlZko4VjM1NW1tZnRtWXhUTnFEZUNmNHk0WXZsUFl5ZFBTRjZ1X2R0YzlEZS1PemxTcHlxaUVqOEU1cmtNZENVQzZKTjRNZEpEV1NTWkE3S2JNR0NyU3A1VjdOb1NJREx4eXZxaUxOM2tYeUhHb25MclpaaFBiQTBtczN3VDRkR1NleTJQVk9DMEZVdHI5UUdEZzlLSXlXZmpLdnI1NEw2QUdRVV9DaXpUcVptUUtFUi1Xcmo2ZDh6M01vOG55LVhYOXM5WlpmdHlGbXM0anNtQUdLSTNNRDkzcFoyNHBjY2F2Tmk0NlVybldVR3c3SVF5UkVCTU5KNHU4RVpKTDhCLW94ODg1UzBTaGNwX1NSM21yR2pZSUp2RzV3NV9VWEI2dWZIMFVGamMxVTZtOTZFY2c2VVFOZDZiUU5PaUFsVy1TM1c5WXRwNmNybUJ0aEZWenM0MFU3SnFHZTVtSl9WT3NxRHV0V3RKM21ZbDQ2X0ZDbXpMYXk4OU1QYkp2MzJZRk9Fb2NTUkdaM1RWbUVMNUFNWVRuUXQ3WUxtaTNRREV5MUZlN2tSZElsZjBZNGdaMUduZEFkZ2VqZ25fYVBHbnRMTU43aFZ1M2UtQ2RmNy1KaHB5VURLWk51VVJKVFYtU0ZyRm1Oa29HbmU3MTlKamJGRENjWVhoRGU2WUVtTFNKV2J1aG9RTmxLTkFUbkZyWHpYRUZ3YVc1VWJoTnUzU2xic3FCQm5kZ0hQcVpTLUVTeEdRVU1iaERIZENPOWZXNmd5eTluQmJ3ZWpFYVdTOGdxUDZ6Q3VxWkRqQzhUbTMxZDhIZHNvMFpHZl9LcVhPem9xeFBPdkNPSDlJVWlid3ZDWkNnZHdqRXFmRWMyU0xNRkJmVHFWX2xhcWdvYVdNU3ZPN3djQnVUUHJNSTBraTcxN0xlNmVpVzhkN2huc3Yzblk5dm9qbVRFVXFPYVI5ZmhxVmpscEd6YW5EZ2hUcHFhRWItMDkyRXN4c0hQcFp2aDM3OElFbmJpcnNzV3lHLXhsRE1MdzU1UUJlUThlY1FMZ3cxUVRuWks5RmltV0ZQMGlaWVhxR2ZlQm5HM2czV2ZFQnZOY2xNVjlrRUJTd1QzSlJ3TjFjMnNDSk16TTZUNE9mdmJWQngxeEhZSlpqakVJYkF4M1F0MlZacS1vZWk1ejJwemtrZDdFUmF1cHA1bU9lX3ZKOFVjVU1oRnJQaFZ0Tk5qOVhLRXhYaXdPV0NDSTgxMXl2cVJkdGZsNDVIZlFDakpGRlJSRkh1NWhSd05PNl9lWkE4NEZxaktNRUlaUHB6MEZPbWlSbFljYWVSbDVmUkhEZHZVNTVsUzQwT3lFbnFoNkR1RXZ1ZVlNOGZfZFBSRUY3WVMtZ055R1NtTGlsNXVfaUFoMG1DZFFCS3BqVlVfc3V3RUdDMnVWZDl5THJyLXBHMDRqRVdWZHVRR2hDckZHRG1pWUF5OVFmc2ZQNVI5MW03R3R1cHd1UHBETmJNaGc0WVN5R0U0WEVJRXQwREY5c25UVUlkRkw2bW41TUVqSVhJTkpMVTdRWFZOd3ZnbWUyWEE2eEswQm5mZXd0VEZXdnZVa2JBQVRndmliQ1VDTDVjdWxENkstbHJIUHpHWWFTYWNyYXJnbGg2bU1IMTQ1Yms3SWZheDlOd0Y4aEg4V1JoMGNoUkwwcHJOdHpyRUFlT1gwUEc5SEJtWm9OX01vMXNVcGhIU09EZ3ZmQjU1TnNYV0tKVzI3VmxzZ3Q2T05ma090UGxJZFpFUkMzSk9yUV9nN05IN3JqZVNZUkdzOFlLMjFVcl9pQURqV1hhcDVQRloyWnprclE5dmNXY2xwS0hKa0paLU1STTJCRmVQZndXQnRJU1c5MWNSUFBoWkh0dzVfUEJhWjY2M3BPb2RxS0Q1dC1TdTFHVXFPMTRCYnMzanBReXEtT3hNYzR2RXlXSlBBekt2VU9iS2piRnpYNTR2dnRIaXBMcU1BM1dQQko1OUNQU3pIQl9KRDFGd3pHdWtrXzhNVWN4MllVNDdEUVB1WExhLWp3dU02aWlORU1NTjdBRE44ZFNRR3BodWZPX2hJbWNoSFZoZkwyQ3I5MFBzRWNLdkNmeXJzRkRJX3hOajNtYTF5dHdzOG1DNDZBZ1ZRNlVyNll4ZzhSQWFreTEzYjZOYm9DTUNyaXNKaHAtMjVfOEFja3RvdXM0TUs5cFl5VktHLVVQZnJaVGFvdGtmZl9EdzlaVklIOFY2QkdTY3ItVnltU3ZRQWdTZF9lQWF3cXV5UTRWOHR3VHJEOVI4ZDZpQ2x0dXpRWGRJSk5NbEJsU2NWamVFZXh3T1NiUTJGeTZsaDlDWnZ2WUt2YVItT1RialR6b1pqTG9hOXY3WFZvcTlJeUliYTFnSjJUNGxQNXFEVGZySmYyRm9wTnZySC0tRU9MQnFSX3JtaUZBNUdzN1VwVXo3NVp3TVBkVWpzRm43LWU4MDRlNG1RNS1BZEFHdGs3U1FQRVRBU2pnZFhuZG82OHVzM0ZKeG40RTdOS0F5T0JkRXVYSVVpQmlOQnh3SFFqbWtzcjVKMzVVS25VTUEzdmEzbW04ZzdRTlFqVTB3aklLTjRPc2ozc0E1dlBrbFhocElnNWV5WFpYWXdQeThkVUlRamVMY0g4YlV5eWRzREJjNlhNRWw4MzVtUS1QbmNkdXdnOHFsdUJTRXhTVTZibkt3cjlqcGlLVUVpUGNQQlc1TkVwTlFwc3FjSnZQMFdBel8yMDRTRG8tVXpCNVRUY2w1MWc3RzM4S1VKd2psaGczZ2R2RFZtNmJtczAtZkptYVItbHNUMlBRNzZER0k4aExobDFaWTBOYXpJbVJ1X21PRWNpM09Xc1R0eDBUNDVCTU53bVBWckpaQWNPdkZyLWtYZUUyVFlVOVktdFRZWkp2LXI0SWdEZ0F1Rnl1YklKSE9yMktGRzZYWW1kNUZWUVVPUGFCbnNFU3ZaVDVKSkpSSkVuaG5TNmVYNzF6MVItOG1SWnJDRUlaTzliVjBma05GRmxHX0RJakVSa2M3LWcxeERnaDU5YXpfbnlWNmwtU1Zua1lMWTdRNTRvdmtOb0EyUDBrQlBZRVk3WWZEMDhNYkpFdHlKcWZRRUlXN3hhYVV5OGVaM1o5SVdoZzJVTVJuVDhzb1dCVVlYbVhXcTF0LWdmRWc1Z2xPeGtBbHZDMF9qLVpmMVo3ZUZLMC1nWjJ6dWQwQzdLMXI3Z2gzc0FnUDhzVDRYcGpyVGtWUF9RcjVxY1phLWdTbFU0a1BMc095UUlNYWVkdDVvSFR4TjExdGJ6bXZROGpWVlRvMm1FamJxbVpqRmQ3Zlc1aE1rSExwUkVwU3RBSTRIQk1laWNyWnJ6YUtvc3Bfa2UyUFp0dnM3YTZNaXhGV0F1S0lhN3RoMktCWkNVemNHX2d3MS1SQ0gyZlc3dUlKN3QwanBUZzFqaE9YeEpaSndkMlZBU0NsaVhOcWwtM2g0a0c0MlBoQ0JQVUNDbExQZFhtTWF1eE52eFZ1SHFpTWMzcUtYblRnWkpxVG9CVjV6YU9sTmY2cnJHM0t2akxSY2Y3eURuNXB0ZkMwa2luT28zR1hnNi1UcF8wUVZuSXhQZWRyZjdPUzhMNnhtTWpDa3hBaWgxTVJUZURwYWdJODB0LWNrMk9OS2YtaC16Q0N4MllkTXk4bFkyNTBkTjZMTFh3OFNWTTBJNlh4Q0FjdGl6ZHZqd1cyUU9OOVBFbS1WVy1pc3p6TU9xcWp5RlR5dldSc0VKR0dUWXU1WkJpSkZLQjl2OWdzTEhGT1YtWE03UVN5bEkxUWE4eWNDNEdTaW12TzZJcms4NTE3N3RhWGdqZWVZdk5YMi1CR0FVdGhnSTB6eFVLd1lwX3dscVM0MGtkOWV3QTJCY3VhejFvSzBFWDFUVmVXa3RDY3V3NEczQ1hhcWRxX1RrM21LclhVSTQxMFVQUXRaWHlxS1dmbFRFMG5xN01hS1FHUXNIZHI1OXhpRkt1X0RrWEQyWU5LZGN4aUNhOGlUNGJScUNUbEFRdTVBSDZPY2NEZ1F2VGw4SWdkZFFpUGNnZXlMOFlKWkZLVGRFUXJZT3p2SmZfVGdFNUU0QXJ6dm4xUXpZQXRHcDdBSE16Z2lfcDd6NmpwZVJqVGQzSEFSOEgxV0RpTFM2UElibklxb255R2hESlRSZWZxTFBjTHE2TVF1Tmo2V0hqTkoySWpZTUFMYU9COWJ3YkxXVmhmcGt5QnQ3Qnd2bTVoUUdUZWU2dHdKWkNvcEUxQjB4OFVkZTdPTDc3WThvOWNic0Rjbjg5a0dMTEVlQWZ0UHJxNUI3LUhmWkNRVElKR0lWaTJMOFBIMXpfMmxTcW0wZnhpeGNqS2lkRy1hQ19mZDlkN05XemFUaG5EQ29KVkFHNjctVFJEMUJXMVp2RjFYSnBTb1ptR1RlRnNiMF9pRWVSbmE1WHc4cS1oTUFhTDBYTmRLa1FQSWRjMkxVcXhja1JFczRNWEM1ekJJWnE4WXNMMldadTMwYWhXMVFZZ29XWHV6QW9LM1VPSi1Dd2pMRkJqSVRSYW5Md1hnS0htNlRNZ1hJRGdmWjI2cGdWSGY4OVJUQ1dUek5xM2FSV1lEakUyNEJJZUVLSGNsZFMyU2lybHBQVVQtTGdSUzFJZDNpbDVVX1p0amRDd0d0b3lvRXdPY19FOGhFZmNNN0lIUE4yUEVYdWNiZjAzMHZRazh6XzItR0hMX1kxOGFnLUF1TkNYajk4TnMwXzBpNFVCVUZ5SmhLOUJlLWY2QjNZMVl0M1o1VjZLU0JJMG5Qd2hST1RYeGlCdnRoMWVEaEVhSDVobTZUYTdZV1RMTkt5clVhd0N0UnFVNEVsbUVHWFB5aHRqcDNNc1p2ZlJOaW9VRVhOOTRYS1N5SnlaUHBVYXoyV0FXYTBJeE56MGVEbEh2TWZtNXV6NmlzeWVTazVxSlU1SWpvUXlveWxyaFBxbm4zeTJYRjRaVXdHbVh4WnhuVDVrZE1lWWlCTFlVTlVQYm9CYUUzUXpxVWFaUVo0eFlWSzlVbElmb3M2SEU4YVpEaUZ1QmQyUU1TVDdPWks2U2VfT0QwSHg2SW5uMGt2ajZ5eGFmNkw1dXlUbHBZSjg0YUFRam05SDhUaXBHNC01RVhSclR6UGJDVjhSSWdVN2FlZlNSTUwwcTlqZ3B4dG1WOGVhMzM1eUtsSlZnV1B0Vk55Wk1VOWpXNGR3RHRIQ0t5S0FaVnJvcDlncU92MDFVS3JJbVBldC0tQmk3V3RSUy1nSzVFdlhqQUNmdGFrcHV3NW9ReUZub0YwU1RCX3V2aTBQZHdHSzh6VEdQOWZ3UkIwU3dOZXpJV2VmT2lGNTdCemw2R1Jqa3E3LU5oX1NvRXE5QnBscXl2VVdRUFYwcmU1SDRXRXljWTVZdjhpYUZQdGtJbUtzZ3V4bU80Z3BURGt4bG5xYkZfYzVLcDRhWHpUUVFnN2hmb2RITERKRUJUeGFqemlKR3phaFh4R2hOd3k0d3JPWGJyamR3ZUFkQ2tuaTVxT0dqTUd2NnA0dERmY2Vaa0MxQVNWaDhpQkFBUHZ0cHJrZ0htRkRBbjMyd1VRdGdGblpNR281bXNKbEw1b3FZWUh6aVVWUVFRNmRYSzY4MGNSWE5mRjQtS3pvSEtMR0xxcEpTZG9oQnRQVDZmekxGeFd3MS1xUEhXMEZ4cDhVeWVZbGZyUTl1UmNYT2pXUEZucHBzWkZvbXVVcjBVbXVwR1ZaTk12UDR5d0xkNjZwMGE2bl93R01QcGxqeFYydXQzeVlSeEEtN2NxNUFZWnBPVWk0Z2hyNnY2TFlpOEVPRG5uSkNFR3FhMTdIeW4yTFhLU0RHZ2ZwMmtPLWZEaS1WY1JKaVJRdUVsWUdCM2JhdmtBZTk5b3ktTy0zTUxsZUtrU3ViWnJLM1lGczV3eWp0dXFTTUVVYlFxeHZCVWk0blRsa2QxSkZRX3lJN0ptb1FKV2tiLTFUbDFmSnkyTERTVS1sMWNueG5yOHd3Q2ViSW5CY0M3c01RZmR1NXo4Zll5WkhfNWswNnc1TGpPRmg1OVRtQWtEUUp4QWF6QU9qOHlCOGlyaTBhVzlzcXk0SkZsNnRuT0VvOVZNMjNzaTdKT3ZQNzVaRnJOZnFnZmZWenczTTZVZnVPR216aXpBODRZeUdHTXQyci1WcFo3M1VoQ1V2ZERUcU5DdGJFRUxNUk1SbVdOTjBvMW1qRk4xNGdaU21jRjF3NVpNZTVwY0RlWnJBM2xzY01CVm1ldEpEWnBDa2FLY1ltVS0xSGJNUUY1aFpSdVRYSDg0THIxYmdHcWR6SGVTSU5kZS1jcTFTbjE4Q0hqZk5naTh1SjBPWU1qS3ZxNVJBWXU1M2QxN0RPb1FqeTVKT3phT3lQb0gyQTlZeFJsYXlhbXZfUmhoUlM0Z1c1OHNvS2ttSmZxZGlBNU92LWpEbDR5QU1PalkxNTJLcFBDRk5IQ0V1Ri1fdXVabDZMb1FMTDZwZFZlaDcxNEdMa2RNanE1eGZmVkVIWFpBTEpKdkh4dnhJNXZzZEROdmE1ajh0Tjd4QkVEaWxwVmtCcWYzWXpTZkc2TFZPNlFNRGlhcnJUaWJ6ZklWNzdHMWlsUnJqUTFkUThGUGRaREtUWHBqT2NOVF9SUC1rcEhXQ2d0dy1WZ2JSTDJPeThIbHVfTmpiMnFEbUpkOVpLUmdnZnIwUEV0aEpqMDJKU1FoMmFDMUI3WmFjWEs4X0FCVTl5ZWRfckhvaGo0MUVkaHB6QUpUM1NMay1RWXdnT0h3NG9YUW5SVG9TYk1SRVo5em9XMEhydnFRS3F5Mm5GQUpsVmotQTlxYnpCSVVLQ1NQaTRBVVVMMnM4SDdtUFNSeTNUbXNfbERXM2NEVUJWakVfYm9leVRrM0dTZmFZQUFBU1FHSFh5NzA4bEpKRVRDbmNaOWpMZ3NzcFpBSzA5c1hxTWN5ZXRoNlNIQXI1dFdSQ3lpWGwtdDNiT0VGeW9nS2NuV3VOWFJwU2w5OHQtTnJLMjdwU2wzd211djRibGxDcU02Z0YyMWxKeUpnbUhKbkxpU2FWcHpBX2RLa2l0UExGWGJpWExrN0hOcWpFSkN5UUJJYlVac3BvN1c2bVFwQS0wb0hYa2R2ZnRYRWtGcHBhRWVGZ0x0QjVBcWY1bjJuLTMxY2pWbVZKdkgwdmZpMjdtNXZUVVZiOHNVemM3S3RFUWlUeW1yVVpIMTZQUjB6VTV3Wkpmc2xoeVRxcWc1OFV1MkdmTHVFd2xmV1dES0VfaG5SejhtVnQyelRHRmFLd3I1cnk3VFpsTXFXU3l6RHA2Q0NzalRFdnFWUXB4bUF2VG41c0QtYmlNMUUycFFtUFBlMEViVC1HejBuVmg0a3RpMHJ0alNuLVNDanctTG1sbDRwUDczMFNhWWJQdFNidTJlcHIyQjRnQVpZckhscTBzMTVfZ2s4aW5ZWXEzT1U2Sy1adHdwZ19xWFNiZlZhN3M5b0IwLV9kN1RFcHpZbjE2MmdPcF92enZVeHUyY0dwXzhwNjh6Szg5dkY4NGhIR2x4NWcyaDhXcjhERERzZFVjLVBsNGpRdjdzUEJzVUliam0yaXNHNnNVZGlObDFPQzc1Vy1zYlEzTF9DbUFrNGtTVFVCbUU2VzlyR1EyT2JXVF9JMlZ6bnZlWDVyajNONEt4U1lRVVQxQUpXRWljMHZkWlJxY3VCWGF3UzRqbzA4WUlhX0NkakNQUTR3TThpSkhNS2ZmMVJ3MGRfZGtOMjRuVFJkRV9sZGVrdW9hcXpCdmhsUWdMR1NVZ0N2Q0p6WmctaHRCeW55dE1xODl5MUJpa1RYcHozVFdBVjlTSjFkNUdDblljNjQxYVUtZ2JvMXpBYk52cWtSRWNSZV9CTnJLVkdFNC1BS1ZWQS1oRlJmczNtbnZudXdBQ2FhNkJyRExXX0xhN3BSanNOa3NYbTAtZWNXQkJiamhwM2pwYkU3VGdXZFk3cVRoQXczclc1RXNWUDRZeEFnOXEzLXk3ZFZHZWllWHhTck93cG5ER2xCNkhVdHNxYmpUNEYyS0JtQVZFMG1rUDRPWVp4TDFLZy1TYVFCdzFyWDNJVzhLU0l3dHFRSnBfamUxam9aVnVfazk3MkZNX0hVaEs1SlNUczZPd182T1I3R0JNaDRoZ2xlTWRtVHNYY3JtaE42Zk5nazQ2TzNFN2lCdkxKdXpoZ2lYaDlMckZpM09VRmdEUEM4aVhfQkVxOUFLSEVqaHJTOWJJRDV4SFpnUTVyMGE4WVN1RDJKRWJ2U0ZjNzh6ekVUcHg5SzMxeGtYckdjYWt2YjlzSThmWEE3T20zYUUybnVZT1FTNXhzdmdDVlZBOTVDSzVSQ2FxTmFtX2xTekpPb0pxYVAxWjVYWmpSOElqT0NzQlZfQnRSQjB5RHVhODViazdVc0k1bkw4WmdpUHJBTDBTd1lzUE1qR082SVBRd2h4aGZSWXhwZ1piVFlTOExoOUFzX25IY2cta0JrNlZ5REFBZ3Z6Vi1aOENtX0NfRk0zMnloZE5zVGJIZm5RcG13Z3VQS0EyMm9oTVBBOWFzVDJfZ2E0QTE2Ym03c2h4Z19GWXo2YnRjT2RydjRYczZRMHRmbTBrdDVKZFVzckxGYlVJc3NoaTlRTkduOHppaXJQR1VUajE4ZUo0TjFiS3NacnM1Q3R6ekJCWEZIMlhfTFZxbUp0aUp4U05uRE5CVV9DMi1VTjJTUWN6WW1KdG9aSllwRkJjMlEyaHRiUldGdDA1VlVhM1g1dkVyakZTY0dKUHFqRVBHUkN4eVNMUmpNbHFQeXJpYzNwVTZLTndsTG9Zc19ZdzlKUjBIdTZKM0Y0Y1ktdnRSb2tCVy1kaTY5Ykl5TndmRHFmckgzNmx2YmZ4Y3JndEJOclVfOFNhWEU2VzBpTHJvdU1BamxBamxONjZ3WEo2eGpxVG0xM0xjWlJCSUZIalVwRnlPZVFsUGJyeFI1ZEpEbXJHdnA4U1U4RlZjR2hucTlMd1EwT3RnNVVvQnN4cUxNcTdCckFDdDJubkxHRG9VNFlYWEY2bUhLOEVrTERfV3RjVmhEZk1IbnhIdDlJNVVNYWZ1MVNLVE5xQWhXd25MSWpMZDk5M0xmMEE1SHRFQXZLQURrRFpyeXVFaTBxU0hfTW5vRW9hTGtRT25SUnA4RkM1d0NVWVBuY2VzYjNocXZRUjdZLVBER0VuLXBDaGFQbzNBaWl6ZDRUOE1nd281U0t5dmJiVkhJYXlzY2FkU0U4UzJEY1pfLU9lNlZsUzQxenkzYWpmazZ4NjdlV3lkZUhHT29NTU5XODZjQ3JLZnVIZUN2bmpWNXZoRU9uQW5XV3lkZ3dXQ05IbVhRN0xhUGtuQnN2bTdtZS1XaTgyOXBNUUxZakdNeVFhbnR5cE5HVTFlYWN4by1nZEN3ME1KVldlSUlWNFcyT2tnejBGbTM2RlJBNTFPaGYxTEJyOFRFcWh1MUhzclBpRGhMc19oTnpMNWFmS3ltSjRuTVhSQ1pNU3Q4SHIwTDJpX0d4aDRGOEtMeWxacEFDRHhnSm8wN0xsc0QyT09QbEl1cU8zY1R3T1dCZlRJbDVZWEVaczlZdGVIZTg2TWwzWjNCamRMQ252Z0VQdHJvMlhuYjZzX05DZ2xuSVpoZjgySkVqNjdSN1FVR01RLU5CbG1iWEdqazFaVGx5Yldtc2ZLZjdCTlhtOHRjVE1CNTRmUTVFa240YTBWUFo5U2R4ejFiOXZwQzlUSlJ4MmQ2eVRuV0I3NDhBZ2NIRkE3TnNrX3REOUxMSm5PcEpzenYtZUozaXA3aXg0VTdfQWZiV1k5djZuNU5vd3dJNUQ0S0JGYVJkZ2VSUHBtbGdQaFFPTWxOSHJEYzRsRWUybkw1V081OGJzRHZmWDlELUktWG5sOU5zMDhrZ19HcDZEcEFGaFg0UmhfVFZZQWhyTnJpQkg5U3A1YmIwMkRiWnltOVVNNGtjTzY3d0JnMkVqaVNuaFFLOXVLUEdUMVJ2dEIyRHhDU1AyVDJVU3NnTVVCQk52WTQ1ZHktLXlqaHBBQnVLdGpmRWJzbmstVENsZEFnMy1BeEJ1bFBNXzl6NkpaQkFNSnYtTEJUa2U2QU81TUdUZ3NjalZqeFkxQkFkSHJsakl6a0Rmbk1xMERSX09aUnloWE04dFhDQ0Rabkt3WERJWTZqcWFOazJfWkRiQ2JOOVNmQU9jYXhGUXRRMmlrd2V0WFRaOWZUZDV4RUV1TUsyb3pBWUdjZ21zV21Ubl9ETGZLZ3F6WG5kSWtlWmNmY3NRSVkzXzBsbXRnZGhTVWt4dU0yY290bHBqUUpabndNSk00OG9YTkhCSUFEUVJXaU01N09kbmVTQVF2aWg0NmZGa2VsdE1HSFpFNWFOTHVHVzU1UXRkQmZXRGZHMDFUTzAyaHZnaWRxVmplZ3FZbmhUbVc1ODlKdnRoZlpsUkVqYzZ4MDRkM0ZVd0lUNnE1Z3NoMnZEdlR3dk0zTG5hZTN6bk0taEMwQUJKRXhqYU5hN2YxaHo0aWljMnBIWjRqbW9RdVdxTEtmeTY5Uml0OTRxWkJoNmR1emJWSngzSHpGSGRtZjdtb1piWFpTRERfMEk2RTJKSnhRMF9wVktrY3JLN1JteHNFaVl3eEpBRnltRVFxMUQyTlBVSTBIc3ctMDNOMUs0QUxEcWxuRFRwX0xlTGNjR1pIMmVoamEtQVlfbms1aWY3c0ZNMTdpSjVLdDJJT1V1S1BZYkZ6M2xvX01PSm4zeTFvb0tCZUt3Z0dneHJ5THYtX25pNUdyNklwTzJQYi1Fb0N0bWpIUEgzM2hWbm5WNUpCU1pQeEd6YmdTM3ZmR1VFVUgwdWFuVERPS1oxR1BHOFNjQktFa0ptdUZrbHZBRWVMVmdtbXRtOTNZUGphMW5zMzNwaEJuV3pmaUtkQ3cwWHFrVzVQd3pxcVNndTdkNUtmQ1RRMDRIREVMZGFEanN5YjRGdVZRUGhmOVBFMG1BYWRjbUl3NVVIVkcyTlRWb0lxSUltOGdsSWFCaWU2bHNUSEk0OWxZeTVwcXpvTnNTU0FSaVlwQ0dNbWU4N3plV0Znbmx4eTFiU1JLRC1HX0dnT1NPdDNpNnVZLVltelZmdkY1T1FobVNCRjhNWGJPZ21JdHNNM3RqaVhuaV8wZDhrWGtpZEFrSTdKSl9KTy1KbFFlenBYeGladDJMRkxGVWhKdmJuM2stVXVpUkg1WTd4TE9zMUw1SV9hWmpESjhVT2lhdldIaXoxSGd1WEtSTGs0UnBpWHFWTnN5d1BlX0xZMmRmWXhybHVFSmttREpiamc1eUpyQmpVVFJoUTAzcXlSVlVVT21nTzNzaE5kRHNPTldUeGZBOW5tX2xETUpyam5IODRmQTl0OV9fdDJMOWJ0aUVQVmp4bWo4MzNXdU9GbDFwOE9EcUw1SFVURTlCQlVLNUdJQmhWSTdUTWJHX0pMOEQ0Nkc1OFJ1Zi1XWEtPeWVpRVlHbFJTdU93OWJDdGs3N2FsSjc2WFE0b2YxUld3ckx2RFEyUHlNelV1LUgzSUZvMkNjUjh6cTF3UVpCOUtIeVlmNE16N3B2b0U2MHpsVER1TXVGdlZUNGFsQlNWUnhKU2R1aFBOeDRpNHhaVkFweFlXZjctc0FVbVZDc21lSVRwUUdiYmpfUVYzNlhMV0VSTC1qVFVwN3d6c21JcllKSmRvRC13dFY3V3l6RmNacHAzXzNCYk5RUGVmLUdkY3dndnFMOGh3UnN5aG91NW8xUGliVXZ4cENfUS1aNy1mX045UTdqcUlsQU1XZWFYUkE1SER3blRrYlJGUWU2SnVydWZpSFMxMEJwdTlnUnYzOHY2OFBJbzdKemg1U01oUEEtTG1fMmY5aGpfZVdsVExOcEJESnpDOG92M1VZVnZydDltZHAyc1JzNW9uVlBjd2NvRTNNNU5KNGJaVzBQcV9lQjJiSTZmc01iTkg2Tl81empwN1I4ZGtzNkRxckQ4YXdaT2xOZHhVSnpyZWlfUEs2aHZHQ1Qyb1plZ2IzczN6ZnYxT1hNeGJSVXdYWHFLdTVBcFNhaU4xZEtYTEpjVmtXS1VJclZ0WjEtU0ROOWs1Zmw1b04xWVV2SUpVWThqZTJEVmVUdHhvVHlZSGtXa3NzcGdnRC1VdzlNbFJvdlVwQkh2R0tNdG4xOW9mZDNpUnR6a3F0TXdhWklqZTBhS3VXVHJnQmVTNVJBbmVWSXMyVmpjaXdZVTAwVmRjbTBZZTNGUnE3dENTb2pxQTcwblVKM3ZKSXFWREx5Mi1TbDZkNG1kaC1QM1NQV2l0ZlhUYy1MTFFSaWZhWWlWcm5aRThsV2hCNnZSSThkVTQ1RmMxcUtLOFNCamlkM2dINEkyazVfQmJCTlhvYmhNYWxxNmdCQkhkanhzRkRsZFptUThGM3dFTGU4Z1otbWdpZDNGd0FYMW5iOVFHd3Q3MlNVV0ZYX1MxR0s3cHowbTJFRVphVkpGajNQT25FbFZEamhGRDB6TkR5dUlUV1ZkdWs0WGRrcXhOdEpYbk9PR1A2a0stVE9HNlRNWFlJNFZROEJuNjhuT19uSEhxdm8ySnoxb2l3cmNEMFN1ZVM5aEFwbHdMM1E5ZEFHaDRrSWdBSldfYWdxV1BnUnUwbmo4UHlnQlRaYTFXUC1mS2FBZ3I4QU54UGhhSVV0d0FXWUVwRTY4UEtkVEstNmRMVVRfY083QUNKMUVSbFBTeUNNUURLRVVCTFBKM3Z3S1dQM3dMU2VJUEFUd2dXUXJyU0Z3ZHZfTmJwWWhReWNMUjNUZjU2NlBQUU5uWnpjQThocHZMSVVQa2wybWtoWm01MV85aVFIeXpIX0JQTVlWRVpGZ1pMcml4MmNzdTFUekVxcm9CRDVGbW5wZ0lmM1RPNWdGOTF6c2pXQkZyekw1OTZnNFZ3RnNPOG1DN0hZSXNJRjJBLWwxSTFvTlN6QjhIdm9JV0R4cHoxdXRWQVVtb3ZQSExnNTd1SFdRYXNnNWJjcE9ieWpjWGlZV2JSZTUzTHU3Q2tRVzlJZHN3OFlvWWxJY0VnUG01V0hxXzg2UkxBZ1YtQXBqZXdPeDRucWF1MTFIcnkwakhLcHJEZEZjZkQ0elV4bTJ0ZlNfeWhnQnFhUFBzMFdRZnJyOFI1RUh6X295Vk5wZVN6SERjdHU4V1d0cWdIbndsdU95X1ZiYVJOakgxdVVvVFZPclY2QUxqSUwyODQ4WVhBalNDckYxb1lsOVA1S3k1Wm03MjByZm1ERlBWZ0puYnJjbmg4Nkl1aUdnQXRZcmhpUGh0VDVhZEtxSXVxek5zMG5FSU5keWZRSl8zbjN1UjNZYUhtaVJSdTFVM3NqUWwxd1hPd1dlZXRrWndwTjBGalM2SFRkdG8zcXZlQjI0cG85NVlOWmxfbVNwZkpseXNuWUZTYXZWWkdNc2l0bmRBNjkwSDJZNUIxU3hEcUk3ai1DV3UzcDdEdTNHeVBMUGo3VmhmdFQ2aE84MGZtLUZxckF3Y2N0QTJjWjJqZVBOM0JmdUllLTZKTHZJLUFuYW5iNnVkYWJnX1h0TF9HUWxlM0dyM0VkVVc3bldBMTNTT2dKNjBDMTEyd295d3lqT1F2aG5IamF6ZC1ZZXBvblZab2xLVXpZR1FJODhFczg1R3FlMk8wc3pEQVc1TVFkb2ZCNnZOMDBYY0l2UkpRUTlVQzlsZ1Z0anNmb2Q1TFZ6OG0yN1JMcDBna1czRERTYXRsalJZWGFic0o3SDd3d1JVdVhtemdFeTJxeU9tU0hBRHU1RHFsTzRYNXhrTFp6bk41MmxvZXZaNFlscDAwQ2YyS0FyOUk5RUxYQl84NjFqY09IekEwVDlaWVlQODNzWmVQYWRQdmlKT1huZnA1NnU1LWtjQk80NlUzeFB3RVlLX05XVW45STVwU0hyY2VVR00xQzd4ZGVJSWFYcjFBby1SZ3h3Tlp6Yk9XSG5SRDMxN3RkWF9jMTktNnMwV2EwVklxTk4zNDA1RTZWdG9Jdm5fbXA4RHJ2Y293YXpOM3RkT0lYTXJRUWdGYjQ3THcwUjU1c3BreXpjMklCMEVDcGpwa1Rndko2VGNfNFRZM1BRRU5xaTdUcVBRbzIyUW54SlpkX3Jod1U0Y3A1d0VIYVI0WWpKY1dySjI5VjdUVmllandIQlY4cTlXOHNiOUU4X0dodF9HdElXYnFEVmVJSHZyVkdZWG9pRzFqRzJyNmM4NEVwN0VzNG5yLWFod1I0c3g4LUZqcThWam1OdUV2SWZYajZmeHlST2tUeE51RFpBYVAyMWZoQXVGb0tZWFpDVElQTGlZN3dNT2tqUzJ5RXk1U1dyRjNQOUI0Wkl0MmVJN3YxMmhoVHRyOHp0VDZLWmhaUFZ1SDhXN0RILVlhemtpd0xWQ2xCV0Ixc3daalE2VGV2UGpobDVId1d3YzBnSjFFS21CTWVMSnd3cHVUSTlQRVc3bXRYRThOSllHZlFNdjNzWl9SNl9WTnNUcHpXcWRJOUd5LUQ0cFhpc2xIa1dqUVJUbENkNTZJSEc3S2ljTGJLVDRnNjg4TG4yUFNtcF9YZjM5OVktYjlJbk1waF9XYjVtei03RTlJdTZMcmEyNVp3NnFJcTdKaUx3SVM1eXFJNDJTZDZqRnU0N2c0Nm96cEVxQVRfZGs3TzRTV0p1eUxsTXRNanFrNHV4QktpTjlxbzJjZC14ODV6b2F5c2dXN0pZdkdFNE1XQ1dXMFk0Tjh6cmp2MVpnTlRfbXAwUTFBd0ZPb0xxenIxUmozbWVCYXh6RW1hYm1WYVhBNnZ1THNBWHNoc1NGYUUwX1JsUWpWWHphRk5UYklZdld6YzY0dTlxWXNOd2pFalU5Z0NYbFBuV3hTa2dtUTdqcGdkM0xpWml3VTVUbU5jN0p4YV8zSkJQeUR1SERtMWl1dy1OaE1KZjluSXpRaWloWk05dVVHNW5UbnJUSjFZTXk1cVYwX3RkeUJCOVR1MHVIMUxYd1VZZXVnNkdmNlNUUDExdml1QkQwQmY5bmJvZ0hZSUlZTTVGVzJlckFWdFJaNnVPVmM4T2ZlRU1aUVVWUXF2Zmc5bGs0UHhQM3l2ZmJFVk52cXlUWnhCZFR0S3FTMWxaZ0Rab0NDbUljejZBWm5tWXU1ZkdQaW9kMlRqaVE5LXMyUEF0Mi1zXzlHdXNIVVhFY0NNanpKRHo3ZndFWjU5X1lQand2VFRqV19vSTBYS1MwZnVUa2FiY1B0Z0pGNmNnT0kxV28zM3FrS204amZmb2hhZkNQbkFrZEtwbUw3dTV0V29Cd1FHbWpYNVFQczcwRWJqQ3hpQ0xudm9iMGFBdFFabDRsbDgzb2hrTWtObm5MRGVRakxRY2IyYVAxWHE0VU8wVFhoQXZOcVB3VTlBSk45X3BnS0hsZUE4TzM3NmJ6NEE0bnd6T1czeHdkZFBFRzVFTU5Ec25lMUI2Tno1ZG1FWjNUV1lJTXBKY1JkcDNZMUllQ2MzX2ZWTjVkSl8ya1lXNF9UU0RBNTZLRjRFZUtaWlYtbWVjckNiOGgzMDNNMHk4WFhtQXY3eVVUT0FISmpLbTc0RkVsQjl2MXFMMjdYNmdWb25kZGVPSUIwOWF1TVVVa2twX3JrTFMzS0t5QWRKU252blRCNnFmdzV6S2psZURaaWp6UHBhQTh2aElwcU4wZ3BQX3cxTkwzYy1Kb3NGNVFneHQ1djJUa25GcEkxdjMyZV92d1pJLXZkTFpOQmxyN2ZVSEdDR0FUME5fRVpENTdyanJKdjBUcGJpb2VrU1RKQlhVRGIxRzEyM3IzWkpuZTlDWmJqSnQ3cG9NY201NzhYcGpYTWI2bVpURjNRR2ZNUklfRkJCemxkZGtTRUxkMGgxR0lRenFhOGtfLVV1NGhpb2w5MUIwRXhmdlBBNmpwOVB2c1hncVNSaU9VZGtSRkk4S3F6bnVJMGtvSWEtenFteEV6QWE3c2NOQVBYbmlvajRxVnkxNmM4VDNOMTM2U1ZRWHhBNzVqcEFsbDdCcnFHWEhQdkxJTk1OeFhzaFlLRG5KNFdGbkFkdGVsSFRFcU1LNzgzTGp2LXRod29xUUZ4V1E1SW9hNnFGM3dSbmNPOEx4LTFyRDR4bGxhMXZnRzczRzVuS2J0T2VKNHg4VXdnQmZhakZ5bzBLN2ZZZUh1YzZpNVVQendSRjlLeU14V0hGV2ZsaTJoWFI3VDk1blQzQXJvSlJmMFQ3eHNMMzBJbmJLU2VZeWIwOGYxSThYY3lVenFCemN3cTg5eHlUdS1pZjNPX2RaMzV6SDU3c0l1T3JnMC14Nm5RclFXM2p3NzNGWjZjWWN3UEtRVjBkYlF4UGx0THdqMm9HMl95NWdwTm9ZVjhmZkxudG1MQ1hVZ29URWZQRkthbGFta3ZtY0NpMmF6NUdXTDdhM0JqTmtvS2sxYnlsZXpweEs3N3ZFUl96ckhCUWVqejN3dlhsN1MzLWUxanVMT1NxeWR4UzBCZjcwN1ByWXVWZk9HVmdpN2pyOG5FcktpbjR3MVRBTE92QkJWZXNMX1ktd2U2MzlqOVZSTTN0MUFZVUgxTkRhX3ZJMEZmWHZ2YlhmUmM5VFhFREwtZmtpMWxwR29GZndXWHBIVnEtUWUtdFUzeXFQTU1VdFljX0luaWpVR3VSSHRGUFRJVDJhM3NPdDJpNEFUSGF1T0FhRlh3ZDFNSXh4aVpDRVNVSlFIQnY2WjZzYTR4UGZlVmRFMVMwTGdObmM5MHVCbXU5QzdzMUgtSzJIaVM5YXVTdnhiLThSeERZb0l5R3hjRmlhdWlqOFpvOUtyVjMweGpGMGFBeWEwaFowa2RMWkxsOG5FQ2dlZ3M1Szc2RC00V1p0YkVLTUdadDVRcl9NZkN5NU9SRFZFbWcySTFVVEcxVHZsMjJXcGc2cWFPdUF3SGtwOFpIQ2ZWNmN4UE83SWhjTTVva0ZuNjZ5bmNYNzc5Rm5xdmZLZjVGRlV5WlowNUpaQ3lVOU9wSTZrUUFjWm9WVnN1SGFPMXEzSm1zV1ZNMkRWQWVGeVViM0R1NEVBck93akNPbERsQ0I2aG5xdW5helNvTjZXOUJmV0VYZXk2d0JGS0dRY3dUVGU5ajNVZWpYLVZ2S2czOTFXN0pNYy1NSDhmUk85QkxmanZSdGJYbmduT19pVE1VMnpUWTBzc3JsV29qM2hzbVpsT2xiRkUxYUY4ZTZubkFDWVprNFRZSmpWT2tVMHBua0FEZ2NfQjNFdzlrcTZNWEtrb1JkNEdMYnFEdzBfdzhBMW5hbVlfZ2R5LUdIanA0R28xNEpPUWlBWlhZN1BjODJVMjdMZVpqMDI2RmpsMDNDM090LTg5U3dJTF9mVFE4anRtT25WT2lJZzlGZzQ0R2s5cFZoaTU2czhWZ1BxbzhYNGRRajR1Z3JycjRLZ1lGR1BiRjU0bUVLQjd6ZjBHUkk0OTlvdC1WOFVJQ2hCeWtyRWZJajFZRGRlMTRNcXBhM0dHV1MxSC1oaEVOLTh4Q2k0bXFRWk1jU2Q3SWxDZUdHS0o3SHljTWk1d1NZQ0FzYkV1eWU2X1RSeW1aRklVajdIbk5CcWxtWHFfNXZWNHRPVkFUTmE3T2pxSjE4bUNheEJWYWg1ZllvUXFPcUpLZVYxcTdQbzFHX2x6Ung1aGYydDVIcGlEX2Q5MGJFWEFPTV9qOXFuRGxocHVjM3J6aTVEZS1STUdUNHFLNllFQmlzYWVjUThBNFk2alNyblA4cW9ZaG9MRF91TW1WWExVZlAyc250SWxBNVNfeXZFc0VxeU1wdV9ZdldCSTB2N1Z4cy1LcXgyMmNjVi1vWFBDN0h4aGFSX3dfdEtNZE1fdFN5MGlOQ0U3NGZqd3FMTHJES05WRmFKbjByU2pNSk9PekYzdktpUnhPUW9qODFsd0c0X1poWXZzV1BId090TElHRFNOUlp6RlpjZ3ZIT21ERkN3VF9Fd2NXaDBObmdIY211MXdXTHVjOVRXRGljYnQzeGxydzNzeW5NLUxqTkw0bTR3RUZSRXhCZk5jWVVqUlhhaEt6TkM4TWhKT2RXcWV1bDlEUFdyUTR2RGE5eF9IQzVPNE9NRFFFNGQ4ME0teUFWWjI2dWJzdFBaYjZNMVZEbl9IN19JMUNxV2hOY0t5LS1zVmFjRElQdTBnSGtMTlM2NjFaMjRXeVFzd0huXzV0WmFhXy0tdnBPc2NYeUtNeGJ0enpXZU4xVUY2bUNlOC1Id3RpaUpmRGJKbjViUFhhS1lfWW4zUGZXTEN6emljaXpLRlowbmx5UFp6d3cyVnQ1Vk0yb2M5enNvY2xzLWI4SldJTmJQYnlOaFZicXVBR3JBMzFrTVNEOGlSU25KWXVhNzFnaFpVcUxWQ3g1ak5WYUFrTUdOX3hXMS1aQ2o5bVQwVERwaDJOWllrM1d5SDlhNEFmNDNLUW9EUG5IejdqUFJ6Q01XaU1IYzExR2diSEJjZDQ3cUVvdjN0LUlldVBOaWZjZ0dOdGQ0VjZERWdCUGxGeG1mQU5QMzBhNmwtYWVlSlU2dVBnbHpuOXZHNEJxd3VWTHdnYjBPZTg3SkVXMklhZTN6U2JuaG95cEpzQUZpcWF5RzdTbFRtc29WbFlPUU5HSHlSTmZLWlhOMktfM0FGWWRHS3lzTUJnd2pZS1M4eVdUOGxpbW9MNDdvdnkxb2E1eTE0aVBHMmdMMFVXOXpjOFRyMTFUYmxYMndfd3ZqWnlYMjdwcDVOcHJoX2x4S2NLek1JRFA5VWZjUzlaSlFrbU5zdGZVckQ5ZlZDMm1CYnBGUFRwUkFxZV9FUkpVZVdIXzVSc0FRY2FpLTh2LUpXMjRPTzcwQkZKX19LVVBUMUZNYksyZVlPQ1lJRHBRVzVicnk5VWd3V1A5aHFvUmNLRnphb2FLLS0xcUVTcm5UbmhDTHRCZTA0WUNWeGxuNHNubVloZno1MGFFUXZvREN4dW5zZFE4NHF2dE9TTzBTYm0xM1ltU0dMVnoxdEhlck40REo5ZGMxSDFtVXpIZGp6VDhrWFU5VzdSVldiSVM3bjZILXRzVlZPWFhNckJWeWpTRnBLa3JEYWRwY2FxYXV1Xy1EY1UtMmNQQTVnRm0yc1dXeGJ5cllMTlNPRzNYR0FieWJSa1JIT3dNNVhSQXB2ZkFRQWQwQTU4RFZzT1ZFbkNyVURlR2JNT25RWWpQVS11T25zYzhyQldDQXNaNV9KWDFvNGhxQkJzMnRHVG94WUtPckpFNG1Vb3lWR3FTZHh2cXRpVTQwcjdKUTNGOTFNcURiVjNGeExPc2RwOXFkdnpKaWFQbDdhTGpCVENHWkMxR0JMLWJ2MWV0M2FNd1VRazVSdWFOdkl5c25oRG1GQld1SU5nMkJUTlFMemlGbk9vY2tGRHRrb1BLeXd2Qm5SS3ZkQnZvR3kwbVZyUTRWeXJMbGE4TGptRDJlWVNJeG93VDM2V1oxMFdNU0x5T2RBMGlTM3NvbThxTndJTGswQzd6MWxzem9VWUFXU1UzaFo5RVN5bTlVSXFkQlB2NkRPVl9JRUJvbi1XRFEtTUo0eVZUSGtRWE5Hb1Z0SXJXYjh3Y0wwa1N1c2c2TnFHWFdWMURaMjhsdWdmM1JHT21XWE9KdUx1MVU1RU5MU3JMZzI1d0FNaXd2WU9QdmF3RXVVczZ5M05yRmIzSjhVWnJXN25vRU91cWVueXpZZ1hQaDhwUzh0V2NMLWptTkFpdDNjc3JjT1FwWHZ3SVBSc0xzMktVWlhhQUtfRTdOckVGbVBiT09JR0Q4Qm9naVh6bVhYaHNXdDZ2M2FXQWRiUFROWlFEQ2hxeFJSdjEyaXVCZzBNV0hNRFpnT2tTaHZMbFJxZllaU1JzZWVHRWpIYi1vZjhTSkdCdGcyOFo3cmR4d3NrODBjdlowNlJiTHNOT1RWUTc0RmtOMXdvUE5HQXZ0V3BjQ2REaEl1aGo0d1R1dVFLSUFSX1BXYTFGamFjMTVXV19QN1pqT3JMZE5tWF9ELTJfRzJYQ2xnNFNVVGpZeC1FXzZ1UnhYRy1ndVdEWHo3aEdYdkk5V2NJdnh6NXZFSXhSVldkYUlGaWlqRDVhWHVCM080X1Iyakgyak9EMmFsai1MWlVMb3h4RENzVkZBNXBLN001dHhJM2Z6OHZqRGU3N0pMTkY0M3BsY1Q5a0pza0VhMmxzVWxMNjhNYm9VVEtNWlEtb2lWZE9HR3pfdTVzQ01haF9XQWxOYjhLYlV2ZlNqQUFwWF8wb3BzVzQ2WjRmd2MxLUs3NllYcWtlR1Y4Mkl3RVdCcGx1MlpnUTB2QVFOVm5jOWlJVHlfeUVHZTBGR2V5M2FGUGwxVmhDYTNEbzZZel9JUWowUHJqWW1FdE9QbUJPNDNIQzRPejFnOGpOal8wWDlLTkVHRjNjNGFBY2dvb19WVzlpWVoyaUdXOTluMGFhbnNncC04SGlWRjFoMDZPOVVvQnN3S1ptOUd1WmxnRzBlc2FCT3p3UFJjRFVyOU5aR3B5RDlxZndKMkVMOTJxblVjOWNQNXVkckp3enE3QWMtT1pLMjdzWXgyNERPdTVSWVhIWmtoWms2VWFVZ2FreWRpN1VCRTc2bFNhVS1vLTR0YTB3cmw5Z3NMVzBreXVCUHMyU1NEYWRmWmdpb2VUc2lUdWc4NEltVkFXUzctTk9rc3JDYWRGbU4xdE1xT2JPVkxuazVWODUwS01QcFc4RkRzcVlZbWI4bjAtbl9sbmt3dDFaRnBWTmpUMFI2UEg0SmRNV2JxcG1wWWlQbGhVaWNOVjBzaWFUY2x0NkFVbTZTa182amJMQXpIa21HMUFzc3VzS0hSQS1RM1BZWlo2Zm5xMUJ4UDVaY2xjNzNvVlUyRDVrUFYwcnAtSmxLdlFpZkxULTQ1eU45ankyVHlncFlUUkF0RDMyN0JrSF84T2QxOVdfbktFcGVQSVRaVzd4TE40ZExvYzF2TnpFYmUweUlNRnpaX3dGUVk5Zk5CUWRfM3ZiOURjZ2EtbW9VQVpHemtnZlJZa3ZTWnJ4NVI1UWROb1duUWdwbFJHR1F6RjN3eDVEVjByT1dhcjV3YVY2eEVJRm05M2xtME9rNFluTnRGQ0taeC0wWGIxamJrVGJfWnUycEcwU0pXMHZkOW5nUGhaZ2VkNWQ0LVM2UEVPVFNhY3QwUFJ5UDlkX0hoTzdzYUk3aHF4amtjZ3BQeGhNWjY2Ylo0NFZjRHJXYWN2T2FJaENBZ2tpc2h2NGRGUjVPT0hsb0kxYjBBOERQRzRlXzh0Q0pSMmoxb3VxRjlNOE9ZYTJmZGZtYTQzU2ZPMjBKc2ZQVnNoSXhDb0Fqb0JzZ2dGaXViRk9QYmRCUjF4bkVkTGtpRFp1ZXFwMGQ1aHBmQWkxMWp6ZE5IenpBZnMtTFc5dFplaDg5MlhHR0hLT2FmMjlfcWtfbmZLbjBKcWtJZGIzd0xCZHJMVEcxa05oZlNmM3lMVjUtTjRkU3BrVjJJd1o2TG9kTnNSV0FUemY2M0R5T3B5Z3NEWUo3clhwTG1WeW8xVUt3Q0g3WHVuS29NekViaEd1TVZzWFE5SXVJR3FvSHVOQWFGclpYTnRFU1REaHRHN3dLWC0ycUI1RUlVT1pOOWxGSE1mUkRuV1JfMnphMkJPNEhHaEZ2T3ZJbDlVT3lfRTRoSjVfd1RINkpVTF9OQ0xBXzNQX2VHckc3LU9lTE11elNxRDdXN1dlbTBBUkd2bXRLeHRuUWFLV0dxa2lwV0dGSUNIMExkdVdnVE04QUhyVWhXeVNNT2VJYnZUbHNFWWVQdUt1Vk9CV3ozcjZEVVFJRWR1d0RTdWVrTEFQc1RBakExbEY4aHBoUEFxT1hsWHZIZGJFZ28iLCJrIjoiZW50M1AwcEdYbHBhVFZRclUzaEFjbjFqY0NNclFFQjdhVmRQUUQwak5DcFVhWGc2YzJkRmVGWnNOU1pUS1dsNyJ9"
layers = 3
iterations = 600000
try:
    data = _b64d(payload)
    for _ in range(layers):
        obj = json.loads(data.decode("utf-8"))
        salt = _b64d(obj["s"])
        nonce = _b64d(obj["n"])
        ct = _b64d(obj["c"])
        embedded = _b64d(obj["k"]).decode("utf-8")
        key = _derive_key(embedded, salt, iterations)
        aesgcm = AESGCM(key)
        data = aesgcm.decrypt(nonce, ct, None)
    source = zlib.decompress(data).decode("utf-8")
except Exception:
    sys.exit(1)

exec(compile(source, "<shadow_core>", "exec"))


EOF
        # FIN DEL BLOQUE PYTHON PROTEGIDO V2
        
        log_msg "SUCCESS" "$VERDE" "Núcleo materializado con cifrado SHADOW V2."
    fi
}

# --- 2. VERIFICACIÓN DE ENTORNO ---
check_env() {
    log_msg "SETUP" "$AMARILLO" "Verificando entorno de ejecución..."
    
    # Python
    if ! command -v python3 &> /dev/null; then
        log_msg "INSTALL" "$AMARILLO" "Instalando Python3..."
        pkg install python3 -y
    fi

    # Cryptography
    if ! python3 -c "import cryptography" &> /dev/null; then
        log_msg "INSTALL" "$CYAN" "Instalando librería 'cryptography'..."
        if ! pkg install python-cryptography -y; then
             log_msg "WARN" "$AMARILLO" "Fallo nativo. Intentando compilación..."
             pkg install build-essential openssl libffi rust binutils -y
             pip install cryptography
        fi
    fi

    # Requests + BeautifulSoup
    if ! python3 -c "import requests, bs4" &> /dev/null; then
        log_msg "INSTALL" "$CYAN" "Instalando librerías 'requests' y 'bs4'..."
        pip install requests beautifulsoup4
    fi
}

# --- 3. EJECUCIÓN ---
auto_update "$@"
clear
echo -e "${CYAN}   ___  ___  _  __   ___  ___  ___ ${NC}"
echo -e "${CYAN}  / _ \/ _ \/ |/ /  / _ \/ _ \/ _ |${NC}"
echo -e "${CYAN} / // / ___/    /  / // / ___/ __ |${NC}"
echo -e "${CYAN}/____/_/   /_/|_/  /____/_/   /_/ |_|${NC}"
echo -e "${CYAN}       SHADOW INFRASTRUCTURE       ${NC}"
echo ""

generate_payload
check_env
check_ip_range_ifconfig
log_msg "LAUNCH" "$VERDE" "Iniciando Servidor VPN SDC (Shadow V2)..."
echo -e "${CYAN}====================================================${NC}"
if port_in_use; then
    kill_port
fi
python3 "$SCRIPT_TARGET" --port "$PORT"

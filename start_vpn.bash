#!/bin/bash

# ==========================================
# SHADOW OPERATOR LAUNCHER | VPN SDC SERVER
# ==========================================

SCRIPT_TARGET="vpn_local_server_sdc.py"
PORT=8080
IP_RANGE_MIN=20
IP_RANGE_MAX=90
SCRIPT_VERSION="3.8"
UPDATE_URL="https://raw.githubusercontent.com/Pr3da7ol/ShadowVPN/main/start_vpn.bash"
export DEBIAN_FRONTEND=noninteractive

# Colores
ROJO='\033[0;31m'
VERDE='\033[0;32m'
AMARILLO='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_msg() { echo -e "${2}[${1}] ${3}${NC}"; }

# --- AUTO-UPDATE ---
get_self_path() {
    local p="$0"
    local resolved=""
    if command -v readlink &> /dev/null; then
        resolved="$(readlink -f "$p" 2>/dev/null)"
    fi
    if [ -z "$resolved" ] && command -v realpath &> /dev/null; then
        resolved="$(realpath "$p" 2>/dev/null)"
    fi
    [ -n "$resolved" ] && echo "$resolved" || echo "$p"
}

fetch_remote_script() {
    local url="$1"
    local out="$2"
    if command -v curl &> /dev/null; then
        curl -fsSL "$url" -o "$out"
    elif command -v wget &> /dev/null; then
        wget -qO "$out" "$url"
    else
        return 1
    fi
}

extract_version() {
    local file="$1"
    local v=""
    v="$(grep -m1 '^SCRIPT_VERSION=' "$file" 2>/dev/null | cut -d'"' -f2)"
    if [ -z "$v" ]; then
        v="$(grep -m1 -E 'REPARACIÓN DE EMERGENCIA \(V[0-9.]+\)' "$file" 2>/dev/null | sed -E 's/.*\(V([0-9.]+)\).*/\1/')"
    fi
    echo "$v"
}

auto_update() {
    local self_path tmp_file remote_version
    self_path="$(get_self_path)"
    tmp_file="/tmp/start_vpn.bash.$$"

    if ! fetch_remote_script "$UPDATE_URL" "$tmp_file"; then
        echo -e "${AMARILLO}[!] Auto-update no disponible (curl/wget o red).${NC}"
        return 0
    fi

    remote_version="$(extract_version "$tmp_file")"
    if [ -z "$remote_version" ]; then
        echo -e "${AMARILLO}[!] No se pudo leer version remota. Omitiendo update.${NC}"
        rm -f "$tmp_file"
        return 0
    fi

    if [ "$remote_version" != "$SCRIPT_VERSION" ]; then
        echo -e "${CYAN}[*] Update detectado: v${SCRIPT_VERSION} -> v${remote_version}${NC}"
        if cp "$tmp_file" "$self_path" 2>/dev/null; then
            chmod +x "$self_path" 2>/dev/null
            echo -e "${VERDE}[OK] Script actualizado. Re-lanzando...${NC}"
            rm -f "$tmp_file"
            exec "$self_path" "$@"
        else
            echo -e "${ROJO}[X] No se pudo escribir en: $self_path${NC}"
            rm -f "$tmp_file"
            return 0
        fi
    else
        echo -e "${VERDE}[OK] Script en ultima version (v${SCRIPT_VERSION}).${NC}"
        rm -f "$tmp_file"
        return 0
    fi
}

# --- VERIFICACIÓN DE RANGO IP (IFCONFIG) ---
get_ifconfig_ips() {
    ifconfig 2>/dev/null \
        | grep -Eo 'inet (addr:)?([0-9]{1,3}\.){3}[0-9]{1,3}' \
        | awk '{print $2}' \
        | sed 's/^addr://g' \
        | sort -u
}

get_rmnet0_ip() {
    local ip=""
    ip="$(ifconfig rmnet0 2>/dev/null \
        | grep -Eo 'inet (addr:)?([0-9]{1,3}\.){3}[0-9]{1,3}' \
        | awk '{print $2}' \
        | sed 's/^addr://g' \
        | head -n1)"
    if [ -n "$ip" ]; then
        echo "$ip"
        return 0
    fi
    ifconfig 2>/dev/null | awk '
        $1 ~ /^rmnet0/ {show=1; next}
        show && $1 ~ /^$/ {exit}
        show && $1=="inet" {print $2; exit}
    ' | sed 's/^addr://g'
}

ip_in_recommended_range() {
    local ip="$1"
    local o1 o2 o3 o4
    IFS='.' read -r o1 o2 o3 o4 <<< "$ip"
    [ "$o1" = "10" ] || return 1
    case "$o2" in
        ''|*[!0-9]*) return 1 ;;
    esac
    [ "$o2" -ge "$IP_RANGE_MIN" ] && [ "$o2" -le "$IP_RANGE_MAX" ]
}

check_ip_range_ifconfig() {
    if ! command -v ifconfig &> /dev/null; then
        echo -e "${AMARILLO}[!] ifconfig no disponible. Omitiendo verificacion de rango.${NC}"
        return 0
    fi

    local rmnet_ip current_ip ok match_ip
    rmnet_ip="$(get_rmnet0_ip)"
    ok=1

    if [ -n "$rmnet_ip" ]; then
        current_ip="$rmnet_ip"
        if ip_in_recommended_range "$rmnet_ip"; then
            ok=0
            match_ip="$rmnet_ip"
        fi
    else
        local ips primary_ip
        ips="$(get_ifconfig_ips)"
        if [ -z "$ips" ]; then
            echo -e "${AMARILLO}[!] No se detectaron IPs con ifconfig. Omitiendo verificacion.${NC}"
            return 0
        fi
        primary_ip=""
        for ip in $ips; do
            if [ "$ip" != "127.0.0.1" ]; then
                primary_ip="$ip"
                break
            fi
        done
        if [ -z "$primary_ip" ]; then
            primary_ip="$(echo "$ips" | head -n1)"
        fi
        current_ip="$primary_ip"
        if [ -n "$primary_ip" ] && ip_in_recommended_range "$primary_ip"; then
            ok=0
            match_ip="$primary_ip"
        fi
    fi

    if [ "$ok" -eq 0 ]; then
        echo -e "${VERDE}[OK] IP EN RANGO SUGERIDO: ${NC}$match_ip"
        echo -e "${CYAN}Rango sugerido: 10.${IP_RANGE_MIN} - 10.${IP_RANGE_MAX}${NC}"
        return 0
    fi

    if [ -z "$current_ip" ]; then
        current_ip="N/A"
    fi
    echo -e "${ROJO}[X] IP FUERA DE RANGO SUGERIDO: ${NC}$current_ip"
    echo -e "${CYAN}Rango sugerido: 10.${IP_RANGE_MIN} - 10.${IP_RANGE_MAX}${NC}"
    echo -e "${CYAN}[*] PROTOCOLO DE RECUPERACION DE RANGO:${NC}"
    echo -e "${CYAN}    1) PON EL TELEFONO EN MODO AVION (10-15s).${NC}"
    echo -e "${CYAN}    2) DESACTIVA MODO AVION Y ESPERA NUEVA IP.${NC}"
    echo -e "${CYAN}    3) VERIFICA CON ifconfig Y REINTENTA.${NC}"
    echo -e "${AMARILLO}[!] Continuar podria afectar rendimiento o consumo de datos.${NC}"
    read -r -p ">> Forzar ejecucion? (s/N): " confirm
    if [ "$confirm" != "s" ]; then
        echo -e "${ROJO}[!] Operacion abortada por verificacion de rango.${NC}"
        exit 0
    fi
    echo -e "${AMARILLO}[!] MODO FORZADO ACTIVADO.${NC}"
}

# --- CONTROL DE PUERTO ---
port_in_use() {
    if command -v ss &> /dev/null; then
        ss -ltn "sport = :$PORT" 2>/dev/null | grep -q ":$PORT"
    elif command -v lsof &> /dev/null; then
        lsof -iTCP:"$PORT" -sTCP:LISTEN -t &> /dev/null
    elif command -v fuser &> /dev/null; then
        fuser -n tcp "$PORT" &> /dev/null
    else
        return 1
    fi
}

kill_port() {
    local pids=""
    if command -v ss &> /dev/null; then
        pids=$(ss -ltnp "sport = :$PORT" 2>/dev/null | awk -F'pid=' 'NR>1{split($2,a,","); print a[1]}' | sort -u)
    elif command -v lsof &> /dev/null; then
        pids=$(lsof -iTCP:"$PORT" -sTCP:LISTEN -t 2>/dev/null | sort -u)
    elif command -v fuser &> /dev/null; then
        pids=$(fuser -n tcp "$PORT" 2>/dev/null)
    fi
    if [ -n "$pids" ]; then
        log_msg "WARN" "$AMARILLO" "Puerto $PORT en uso. Cerrando PID(s): $pids"
        kill $pids 2>/dev/null
        sleep 1
        if port_in_use; then
            log_msg "WARN" "$ROJO" "Forzando cierre en puerto $PORT"
            kill -9 $pids 2>/dev/null
        fi
    fi
}

# --- 1. GENERACIÓN DEL PAYLOAD (Self-Extracting) ---
generate_payload() {
    log_msg "SYSTEM" "$CYAN" "Verificando integridad del núcleo..."
    if [ -f "$SCRIPT_TARGET" ]; then
        log_msg "CHECK" "$VERDE" "Núcleo $SCRIPT_TARGET detectado localmente."
    else
        log_msg "GEN" "$AMARILLO" "Núcleo no detectado. Materializando $SCRIPT_TARGET (ULTRA SECURE)..."
        
        # INICIO DEL BLOQUE PYTHON PROTEGIDO V2
        cat << 'EOF' > "$SCRIPT_TARGET"
# SHADOW PROTECTED | DO NOT MODIFY
import base64, json, os, sys, zlib
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes

def _b64d(s):
    s = s + ("=" * (-len(s) % 4))
    return base64.urlsafe_b64decode(s.encode("utf-8"))

def _derive_key(passphrase, salt, iterations):
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=iterations)
    return kdf.derive(passphrase.encode("utf-8"))

payload = "eyJzIjoidThiaFpRNHczSjJkdVFPY0VKUDBsUSIsIm4iOiJTSko0MGgtNWZHWVZDVVIwIiwiYyI6IjhkTUk3T2xRX1JVTE1HeHhHYUZMZUd4bGdWRllZa1IzM1E2eVBFMngwMkx5d0NmZV9WRnNzWm56a3RNbS1LUV8tYUxPZlZ5V0dzUWNKLWRmMTdPbkZhZTlvdXR0aVQxWGVJRl82ZzFQSUgwSnZ0ajFkRFV6WGkzZG9oX2sxODVodDV1M1diT1ZRQ29GUTUycXRYZGE2clRpTzM5RHZjeWFMVVJaUnBTcDF5NS1Qa29PQ2x5VVFzd2RZOWxXRnpIS1JvRjJIbFNCdTN1bFRhSE8zNWp1M25JWllHWTRvSk9oSnhUOTNGbUFTT0hzaGtNQ1lwY0xsSVhKdk4xQ2FwNUQtVEIxa2FPV3cxWkFUQ2xUVzgwN2w4QUZOUmhqREtobDl1QlNtRDc4aU1SYzV2S0trZmlMTXJPWnZXeU55bVo4a2JpQ2JBVlpLSlVNY0hlcmRZRXE3SnlxTTJENEUtY0Z4UUt2RFhiVHhUNjV5M2pISHgtZ1NSejFjTjZ3cTczbnZJRktJOExJX2RSckN4WmVjbVJZWVd5STZNM1VGdEJzRnNlaFkybVZfZFJmb1R5Q2ZNTnBkUlZ3UDRPWC1ZaGJSSlI5WXFJRHgtOENuWW90MWlHS25XbHB0ZXRMWHhUX3BYU1dURWlKSk40a2ViZWZaZlNGZkdPVUhvZS12Vnc1YThWTWttMDJrOC1meE03TERoeWgtVFJrSkdGQjVqM2tVeWtqYnlLSm5SNTJjMnh1dVBjdjFHY25rNUNIM2pzSmdLb2hQMEdBZG5RT0NRRTVFSmdYVkZHNnZ6R2Z4U0hNQmZiaUZRY3REdmF3ejRzYWZMT2dienNZeURGWk96RDZyVE9lN0dMY3lJOG1DUnJjVVFlNUY3UTQyX3lLemlaSndpV2VSejVST09nUFBvTkVmRG9felFfNk1HUTU3SW0tZkphdDh2Y2VZRFJBcTRSaU0zY3MtQWZPcmtQU3BMamxiSnZDQUZ0TUp2c1NFTkhha2w0bF9NMlBNUVRXdlVXTUZJRmVkT00xNVRiODJHeE9YSEtPbDJvU1Z4b1pCSF9MX3MwLTlhc0xsWkdrMDBiWFEzMFVOSG1xZlhmdGdCNUZxNGFCVnBQaUVPWjhrdnZiZHFMLTFjTzBUeER4dWtCdS1SWENfZkVwMmVmY0Jha0JYMzJtcGNTN1NLcHlZcFdpTDF5V3ZpVkwxZHdhVlItNmdrZEdmLUR3T1FLODk0bmp1VTJES2pZWnZVMFpyZW1Xbk5BNHhXa09PdkJXRDg5a1k3cGlPbk1ZYkxmWjQta2RoTWlhRE9hVFhIYUxMeHJ1ei1RNU1SWFlNMHBNS3A2M2M2MVFEdS1TRXUzLW5YYU12NkhzQ3ZvNWlWVXAzYkY4d0ExOVlCT1VGVTRQYWVkWkc0VkpyRktnOU1JckRsODFzTFBXS2NoSHJPVFU1YWJGSDBLd2ltdzM2eW9ZTWx4R2lYUW12NmJGQWJCUGVYaFE4R2NYTi1hZEV3N2hXNFhHbW9ZaE8zNzZQaUtzN1diUmw4TjZ4WGlYaHVGZXdPT1hVOUZXcGJvS0FxM2NFdjlYdUlxQWQxM2hJc25vVk52ako2YVJWdHdZbHo1RF9ZdHVTOFJKMUhIUjZKbGk5bFlwNnktdDBmNlBHRnliUUViWlNwLXBYcEM3NHNTN25KZndybXpPUUVKX0ZGTzMtczZXNUlwbnhiNXZxOFg1SHlkNmYyRjRweXFnejZ5clBpZHF5YWFvRjNGbTM3dXBhYUo2dUtHR25QQ2VsTEJLVWVDNkVoYkwwSE9sQmhEZmNQcWgxMUVibUVFRjVlUmJiZ05BV3VVRlhhNVBFRnhSQVRSOXZJVEtMT295bS1fcnJXWkxLUExyTVdTU3dYOXhOQlZwUThqVTgxb1ppZHJ2S0NtQlpFWTItanhXWjlJVERqaUtZNXVGQkhJcXhHUVJXWklkdHVQQV9oRklORkRkOGJiREU4cnEyNk01ajlxbnhTTzJoc3ROc1l1OEY1NU1kbDduQS1hWXUyVHJJYkhieTRtcmwyWkRZcjVWR1VJNWNXX0l4a09RanJiNUNJdG9sNlZkOUxRcEZMdmJjUzBPMlF6eEVCV1h4U1BUMUVGcG80YkF1UFJ1TlZDSjlndTh2RFFCbWFkcTlvd1RGdF94Y0ljUGNpbF80UTViMUhzWkY5QTc0eXk0ZzVWVEJJY1c4OWMyNHhUb05DakZXVGd4eHk5SGRpS0JuQXlsRjJYalBBZU5OVWFBSVZReF9ZaEpBa3cwekZKNnI0UmVRSHB5Z2ZWV1BLWmJGY0pTY3BZdXhQM1FFOWE2Ri1VNjNCODNIbV9uNE9reHpzZ185X095NHdOalpXek1vR0V1NmxpSjhUYm5pTmNRRmNZV01kUHhfOEVjQ2FDc0ZfTzlPSkhmUDh5b3h2dDVYcDF2R3J6Z0JZMUY1di0xd1oyR09GU3NxVTR4UjRHZDdSMzR1Y1BqdEQzWlFwWDBsLXcwMnU2YjhBN2paMVdwZG1rX3JYRUlmYzl3MDNPOTM4RWxzenNNTVMxRFlOXzgwNmpJQjlfLTZ2cjVDY3Q0NmY4dmJQbDFnWlZRdEw2VVo2YzhWdC1iUTNpbnQ0UW4tWmhoMFoxZlBuM25UWDZFSm8ydnVFOWZCOTV1WHBCN2hSOEhSbEFJSWVQSWNhQW1CNUQyN1Z3UTNrQ3ZuMzNwUTl4UE15bHNQeEdqYVdNZS13QmQ3d25BeFlpbHVQdW95NWxRRmlyY3VIS0xsS1BhNnRJeExaX2c0UHhTNlBOVDRvLTRydlptTERsbmJIRG1UNlVOU0tic1ZSWXZIazBHdHBncGNnVm9rTHdGbGdfSlE4RVpfYWVTSjdNb0xNQWRJSHg1Y1lWQ3BFdkduUHpwU3J6OGlqbEFEWjRBM0xqWUhXN2FaU1RqT0s1cWJ4bzNUcjFlMnlMVjJtaXl2QnZCc3NNZlk0OG94c04yYlh3dkVHTzFEczYyMmRJZENJaVRiTlhmWmJGSGhWejdzVVhqNVpwQ0ZtZEdVdjItVXlVNEs1cGFIRnhMMUJWcm1kMTcwWlZyZG83YUFVU0VRN1dacFNFSm80ek1CeThFRHFhMWRab0EyOWZ5VjB6OVZwNm5kVDNLQ0JTNV9fVGpQVkMxM3BhUWZWb2tNaUtMOXBJajhCZWN2UU1QU3hpc1Bxb254N1NMZi1zVkxsT0htQ1JuRnVPRlFObzdSa09KcnUxYnd3N2xhUnczZTg1Sm1MakNnd2lBVEdHckp2ODlVelRsMnFGV3ZlbE9SMGk2dGZGeTMySzB2WTllUFRIRGJ2TFJHZ3VBMzhJR0tGX0d6dWlmX0IxaE9yZUd2VElobF9QRFJnNnB3MElja1h2UHJ3THZlYV9qV1dtQy1WdHpaNXNOMkExVGc0dmNMYmFYcUkwei1XOXdvajhPRThMNVdvSHNFbTBjM1JYNU5tOXlBbGtzZ0dzSndGSjZxWGlVZnJUTlRUZzh6LU56RlFMM3dXU3NoZ0ZmSnpjTkRQdFNJTEE5U2JmcS1CQzY1WklFQ3lBR1BOWHBHMG9xcW5CbHVMNXZWRHdJZFh5TW11U2VuaDJDU3ZjNzlfQlB1Q3dfa0JIQTBPYUVQNTE4bzc4YnhESHBWdFp4bWhDekZGWkU1UXFkR25qR0g5Wm5rdmNJTjRDV05vNUZkREs0LXU2bHQ5UkZaM1g0RUxvZ2pRczVQVWVTVVRQMEtXVDE1Z1VSM3M1OGFkSmhVOXRzTE9PSmdGQWtTTWs0Qk5JWVNPZEU4SDViVE51MUE1OE8wam1tNVdKd2FSZVg5RWhLMEFjcWd3WHV4R1FveHdrYVE2Ulcxbk9Rclh6SmFrV09kSFk0ZzRISlN1UlZPa3Q4MWp1b3NISUFaUDBWQnRZaHQ2TmN4QndIQzFlWThCYVVJRkJSM3lCTW5KRGFfNGg4WlV6b2hDQVhGRzJXNGJXY0VvcHVNSllsVGF4UlFrMEpaZ09BbjU4bXR1VF9uZGQybUhuRlBrc0ZMZUZmUmJhSTE1NHU3eVVhdGhtYWR0TkN2VUxycWNxSzQ3bFhONjhLSmh5U3JMdXYxOWthSzZjeVhZYjFvdE1jTHZiaVMzSTNnenNMU0hJVnZiV0RMVl82VkhMV2d3YzBfWWtrR3hjTENac280SjNuc0puVmc3NVUzZzBzcVRtSWkzblRHUlRPX1VHMGw0Wl9nejdXamJNTUp4TWtoOVVGSzA1MG0zeGlZd0FpZEJYRE0zckNCN3ZTNXJvRncxT0E5RzRDSTR5VHhWcUl3ckFISHRXVjEwMDF1eTh0SHlTajlWWDNIRzBLVnA3bnd2TGI0YTA2bmllZEpsdmhFNkl0THBseGpSUXhoUzd3Y2d3NEV4dHc0NXlCYXBITU5qX29lR3VwVUxxSTNGYk1ZNlM3bGZiVXh1X25SMWlKSnVmemNySURyakV4eEV2MHRXbEEtU1ViZWRuVUhDdGxwTUE1MTRaSXR0d2tuQ2ZYM2NoR283OHpyUUNNa1Z6QmQ4Y05McXRBa2hQckgyVFNHTW51YnBaTHlycUJvbWx1S3FWSDFWM1FjVzQ5bTE4QU9EdTlfQUZ5ZFVROEhJc1pFdVB1RXhleS1GQjBWc2x2ZWRqZlZjcnZpbWpJTk9RdUlfVVFHcVV1UVEwY3U5YUtxc0x0Z25fYVh2NmsyVE1IMU5laDZqcU5lME5SYVk3R2lpSEpHanpMNkxiT1hReGFnd0hZeGEzT0Y5YS1aN21FV0VvalAzVXl1SkJOZnVLOG4tV2dkZVNqUVhlSUtaMUpOUzhHX1c2c19GZUdSbTBiOVhxZWphT29FcEFxa1AzVDJ1dE5pSDN2VGFfSndtYmZURkNMNXB0cXJIUm5Tdk5iRk5VaUJTWHdHQ0s2WTk0djJPYkktTWJuTFZVSXR2YS1MRmF5bDFTYW9IeGNlb19pa0FhZFdBWl8zZF9aTXFkVWwzb2JMa01CMEI4QWNGX19zdlQxQTJ4eVpIR2pFdG52cEUzV2Q2TTBjdDdSaHNaVGNKaXNDeEVneXY4RUVRakJQQzlCYmk3Q1U3Sl9LOHhJVmN0STlLYTI4OFdhOTNGdjhtQUtSRnRiVnBselpLRE5YQW1PMWNSWGlvX3F0SWVFME1hd1FQNzRZR2N6VzctQUpkSi1qekpNZW9Pd1ZnQ0ZVbEhuMlhkR3pnYy0wUWtnV3MyVzEzLWJMZnhUWENtNWQ5bmJXNlhxOEhKSVlMcVZudl85TlV3THpRRjVoOXZHbmd5NXQ0R2Ywb3J6Z3hhVllkZy1yY1U3dDNxMlBvdGpmYnVTdEJrN0MzOXdOenlvcXdScGk3NjR6RGYtSnVrbVFmUHkwNGxScXA2Mmlub2NnTVhIZmttcXVFQWlrTEFCWjRBckd2RWVuTDlaZjlKRF9kdmF6MTNuci0xaE9rQUZTNG1JUE00V05icU9BNi1kVU9UMnBHYUZlR0NWbEFEME5xZTc0d1VjcHFyNGktZ2ZWVmlXbnRodkFOZjFnWkhDSUN6NDFhVlJSNkJjMGVHMUxFV0ZTRXpOck5KQVBYWnhYaE9talB1Rk13TU1RLWplX2RKdVNWWFJsRW1aa2VabFllbjFZWG5lbjFKTjhpemtITmppb1djbE5WOF90ZDFuRlJtVmt1T2hxMFpIdTZOSWg4cWdiaGNiNk1QdzN2NXhjb1ZHbVFVTlFMa2ZFc0hjeklkZExXWENSQk4wa3Rxbk5ZUC1BSnJWVjloRV9kckpjR3JzNEstNENWNW44UmlVQzgzQ09WRWdNZWRwMkszQ2Vtc2I4YjZUalpMMFdTQ3BVUHZ5MzFpLWhJNVVxWnpuWENsU2otbzJnTFJuRW4yUzFBZ3l5SzhMSmx5M1ZiclZBZjIyNUJESUFYZ3RFWFdndDdXZXJKRkdXaklWMFIyRkJoMlZ3Zl9JYlY1MlhoaGc1RGs1b3I4cU9xenFYSi1SWnk2THNmRzlVbXptNmNqX2tUU1JsYWs1R0hPVURDMWQxTWg2ajQ3aHYzREEtZ3p4TzNaRWF3SWZzMGFoeFFyUlNpLURDSEJvZ0ZrWlhKVTl4WXNha3RRcUJtVGQ4WkUzTWVPbFlyRU1pQXRQa0Z5WWhoRDB0bWl5U0VWMExCeXRKUXZzVlVCWDRlbmNuNW1TenNYcFdNSTJOV3FpQUhjbE1WX1JBSjV1cWthOUNxakw2ZkxNX3hhSFMzeGEzTlZxd0R2Q2phYXFRU0dhekhBcmtuTHRfRnVoeWphLWQ2LWl4Ry1iS3hHYlhhdzZlR1l2em1Wb2hxNFg4MGE3dFR3blZVYjVHS1FRejJaOF8yTktYa0Y3WXh4V2haSlhydmU3MjBSMERuODBndkZzZHg0NDA1aW12R3NLREo1YVBEcXRSelh5VndlS3ZhWnFZeWZuVTNkZlVFSWNoQ0RHZFAwak9SY3haUUNyaFpQdzd2NHA1bjVOWEU1QVJ6azZOd1JaVG11NHpuY2kwRFBhSDhtV2Q0OEZMbXhvRmZRdGRZQ3BTY3FiU0hid1B5N2FtQkZESG92ZXFVcnAzNnQwVUV0X0JucjNMTVJfUmRJdWZNVjFMam5tdEpvRXhybmdGR0lNRXdwVmFfaWx3ZE1qWDV1eXlFd1lETS1iSTBKS3JuOU9rX0YtOE5BMS1BMngxY1R5ZmI2cW01ZjZWOV83SDNxTXNoZTMzQTl3NmxNeml1YVREazduRThNQndvZXp4czl5bnJBVVdYLWhzZmczRmpLT3lVbVZuWHVoamRfcjVfRWwxZlg4YnpZZjVyODZyWnlPYTB5V25rNzVmSktZOUZhQ1RrNHRxQkhVdHhtQXVlX0poUHJ6UkRTWExudUhYWktZUUJ4UUVQOEpPdHNwZmhfY3paY3VZWjJSOFI2Vm1PM0RYYXd6Vld4czVEOUI2U3YwdUJVLVpOd2Vzc05BOXlzbUNHUG81ZzRBR0VvbEsxOGhIU3o0bUFYOXVMOTExU1k2ek8wSzRLek5CWkJaN1hlM1R4dnA1UTRqanM3UEdoOGhZT1JHMzJQWHBhRVlKNm5WUEZVZGw2S2U4eFBvQjVoZHY2VnBwX19QTXctMTdOUWVFYkJuTkhTRXVYZlhSNThYZG5FMVh5RFRPNGhkUTFFNWhuVWpwRmhrSkpuZGt6SFNWZW9JOUI4cGt1Y2phR2dBdWZCX3JURTJGeVJsRFFKblhNUXhDb0ZuUnQ4OXJLX2VGZkc2aEFkY0NkbERmNkpIZld6SmduRmtJV3ZzeXZZTFNzZFAyS04zaEZzaTFYRlhHSlJ0Z3BCYkFIdUlDcHJ1dkdpelJKT0NROHVLTVpiSFBaeWRGUzlnWXNITURQUGd6aV9YMmRvbGpRYldWaDhobkF6d3UzOXZsZEVGVDA4S2ZqTjFZV1o5LXAzVjFiQU9DWXpSTTc3RU1KdkZ4RWpDZ1lmUmlvWEFZMXlRREFBWHdiSkl3dHFBZ1hOVmlfTzNjOFZiczlFczZrR3VqQUNRZ2NaVVBsQTZhUnpJaFZJcHowX3luU2ZqY0xUbTdRYmFndXk1Z3VCUHpjeHFVdkR0YXhIVkZJOUNFWnVwdUNBTUpQWTAzVUN5aXY3OHNXMU83Q0VrQmIwQlZpcHd0ZnJxSHZYOXdZUktTSWRJSTJHVXBmNkpIY2FNcDg3cUZxYnl6ZG9FRFNoTnNEZl9MeV9nSE5XUFB2THlVWW5xQjZqZ09Hd0pxYzg0c2ROZWRmWUR6Q1QwcGdtMFRaNUxqOElvZ2N5T3BiRnkycWg1WUFiRUc5b1lRYnctTFFIYUNpemJkTnlLUVd6dldtX3d5elk5ckp5QzJyYTF4SnlrSHhCcTJ6LXQwTllKQ3hfa3JNdnlnNzhLeHo5aS1uaFdoRk5WYzJEYjNCc1lVaDhvZHdpWmEtbE1IVF8xRUFhbU5Gb1hXeFJwMGs3ZXZGclo4WmJTYnJ2OU4tTDBWdlJTZ1NOQXl5aG5hbmoyZ3h0eVZFQ0xmWUJjVzhobFlHM0dHWWg5NGlLRXlBTkEtc2V3VFQxamxwSW9rdXlucHFJSUtZV0hvTUY2T1BUMmRIcnNUOWpCQlA2bW80LUNmdVEyT3l2bUNZbDhjVUtQNTk1QklrWGpGVEJfSXRLanU5Vy04WWhnQjh0ZzZGLWJoUlB2eDItYU5OQzcwbHgtZDk5V2ppNmxkS3FQU3QzbHdMdE1FWkRqOU5fTGFXNlBQS05qcVFXVGc5ajhUQzF0eFdNOHpta01ISktNcU9LdXUxdWxKVmVqZ211S3FYMkQxLTJ1YVZURGtYWDdVZ1AwRlZ6eFU1TUUzb2wxaXh1VmlteE5IOEFJZExZNW5SY2pESXo3NGJBWkxUbmpCeHJNRlJWNnBrSjdIVENXSW1iV194bWlYaEVmYS1JN1JmcGhWUGFWVmx0aVBjVFBDbVIwQUFtWmpBT05Oa0gyTGIycl80THFUMmhrMnd0aExMVGtwMDhRT19vcm1hSnhNT3Y3NTBLMVBoUzBqMWdYVWhLNE9XRzNoWDJmMUk0NVozUzFzTVBGdmtWMmVKNllnbERKNHRQM29RWGU1QmRMMi1ZZVRkYXowZ2FFZEVMbUhET3dGSHptNVZ2bXdFMU5DNnVSN3pFbGlKcVVTV2RaeW9JNFRaQ0dmbnZyalVIVllKa1U4ZlhhTV9FV2kxT3BuMkhkSTUzRml0MWxfQkpvczVRUDdSaU5DVjh0TlVEek9nNzRVTXIzNktKTVRVc1pod3RNVDBDRDNWc1pfZFItX01scXhTUzBNNXFoLS1GY2laYllYNF9Qdmlta3hFR2pONWNDSV9iQXhFNUxWMHdIX3JsMnpKZXRoczZ4NkJhdlJaVXFVbzJqbnBTc2RXQ1V2RzVEaS11amhWa0dGUWhacFljekdURTB3UkFON0duZnJYdmhzRHVpSkdTSEpCWnN4UWdQS2l6OGM1S3g4SzFNRW1rOHpManhYamp4emFnaksyMHBUWjIyM1l6d2h3Y1V1U0UwN3BmQmVqc1JqTTlVdXA4eFFLT1VxMlRuZ1h3UmxoQ185TzhCWE1aMS10QWxjWkU0TGJTTjJSUm9Gd2FYd1VDb0Z5YUpjMmgweWZEX29WMzYtbDZuT0VHSXRzOXVQSDRtRmhGVU5yaDZzR2ZwLUtIM2ZRTGg1dUNXbGo4ekNhdVZfblFVb3hLZnduaUJXOG5vWXFVakIwSDh6cnRKOGo5ZXM4S3d2dXpxTVo4elNQUGRtMXhCX3BpT0RFMVNxVFlvblJyODMzdlBjd2xHbUpfZmpxcUV3QlJEQVlLR3JKa0lxemRzSkZzVHRpYjdPU3c4RUM4OEprcXJIUTdaZWlrNjB3clVWMGpoRHlqRjhVS0NwNDZWejh0UElCUFV1ZDdxSFMwWWt0UjNZalF4MThPUVd6ZlBPTGtlVV8xMjc3TUxjeW0yaEFGRlhPa1Y5bWJYSlRwdkJLM1JRMFVZbFlhdy1pYWwwRkh4VGxncndPZXFGSXNrb3RBcXg0aVlLWDNaWHkwemFFalhNazAwdHV2enJ2Rlg1SjFIOF9BNDJQeWNhb001N1RkWU5xOWdYSUVpX0s4ODVDM0VqZkw2YW80bVhtTGV5S25ycl9ZMWNIaTJIYWl4UmtPZ0s1MkRaNW5rRmtmTTUwWi00b3dtTmNIYlU3NFdJTjJwSTVxaHk0NFhXYkM1d3Z1c3FjYU1sTFJJM0pOT0YwdmxNZlg2eTk3Ulg3RGF1ZHROSlZrNEhKR1l1ODNZX2lHdzlVMXFxWkxpd2w0QWJvd3kxYzEtQ1F0QUl2R044TkllaG9hOHoyYl9wdWt0TGNtbU5xV0x1RzdfZGNNX3F0WHdiekI4TTNMdjBLQUZ5OE5xOGlFTVd3TmlMTGJLd1VlZVRYakRsT2hjOXg0dkxmYjhMd2FiNVJJREl0NzBndUJaTWtweWFPcmZLNmFydEw3cFhtRVJnMEdocXdlN2FWYnUwdFpBNDFCakxLTWpPQUM5VHZlQ3VoT1JYZXo1WFVmd3NvZDF2U050aWx3QUdKb2VEeUlEMmR6ZjBrcmZQeFpWRmpPdEdvNjFXRFJIMk5FQ3dUV3hhT3NsTHBfZXRwWlF0X1BwU3dzWU0wOU9FVXlOYWRVTDkzSVB2elREakdFTUYyOXBtMlFWZ2JGSFh4RmtqV0huYnZpTzZTVThlLTNUQlFaV1U4d0VDdHk0ZVd5ZU9rMTcwOXhPMlZHeEJ5RVY2cktvUENqZVFrUlkxLVJBcFVCT0s3QzVUelhtbGhFbTJzVUZUQy03T0tid05kRFFwUHEtV0czVHo2S21LeHlnVGdYSHNGMXNiMDc4aGFIeFRpb2RBYmdQVXRlQjRJMDdCdUJaYi02SXo0Q3hxeFRIcndZR2hsb25fZHMwVHhrdThGWkM5bXRHV1c0N0prLTJqYVJvMGlGQU1vWWZHcjhONDVVOWtRQ0RRMjhNYW02bWx3ejBLWGQzTldJRjZtZ2lMLWstczVsT3Q1aVNJSmRIc2h3NDBzX3VpeFJKWERtRjQ4UmxaREZRVjNIV1FycGtnQlVVOFJhRW5xTXJGRmc0WW1FdXlWS3BrUnNHWTdFb0Z1NjdMY09BMlJ6LWlLRld3NTZtNERtbmtVQzBkLXQ2alZSNkVTNnRiMkw4YkNza0h3dXpMYzZQRk10SDU5ek5lSmtMX0piZngtUVJjREd6dU1BSF91dW9kNEJTZ25yRUd4UmI0WXRtSGxhRU9udEMyVGJxNjFkMTRmQW1iVFU0cW9OSUM4c19MbmFMUnNucVlaTFpqMjJLeG9BSnh3Y0JUcEVpTjR5M2NOLURsMEE5YUlXWnVfYnB6aGxFWk9vUjJvT25MaklWSFRYak5RT2xQNUtBNFhNX2V6S0pPQ2IxeXJ5Skt0QjVxZ3FFQTZLSjhveE9KZVFYTVRlNnE5ekY0aWxFYWlKWG5PY3FkUThDd2VRazc3M1pVTElhUkl3eFBYcVNVZkJOY1FCY3hRU0lwZExEWmFqcmhnd0NEbG1VdV9pM3Fmd0ZMQ2ViOGNqYVg4WFlDYkdwZWFRNHVRMktfX3duckNPcGdWa0NaaE53czF1NmU4Y19fMnBGaDBNZFNHNkQ2MFNHVkdsTDNocVFkbS1oSV9UUGdvOHNMSjJmZ0R3TXFCRFZQRU9hb1BZME43bGwwSjRTVFdGU1Rmb2Z1cFVQbm9ZSkhRdHJ4M0pXVTNxZW5HNXpYMlZ5ZHYwVVNoaU5PamdFZFp1Wm1XZGJTN3VQS0huU0RPNHlSWGxMZ01rcmVZUTB1NmNHZ0JwN1Z6QVhZa3RpTVBVNGhvYVZCdTZmOEs2eDhxZmtOU0d6MTZMX3lKdDAwa1ZYMGEybzF2Zk4zUmhmVExYMmxFRHlodEFYU2VXX2FoTndDNVJmVjJuUFduSlBHWEtFYk9zY3otRFNiSlA3eERmNncyYTY1UGZpaUVDLVVkY1k1enBHZk55OTBDRG9NZnIxdU9CZWhVbnJKNXB0SXdnNXRTc1EyMThZd3BNVko3bEYwRVNjaHFxejlsNmtocTBiaVZreFV3VlZEM3BBdUw4MWVPM2pBa1YxTE1VdTBtVmlZVVRfdWFCRXZiVDdZLXJVMkItRW0tOUZuYnZpVl91MzNrVzlYWmRVcW8tbXl5cUdxdk9yaV8zTFBvcE1WWlJoZXdfc1dURkxXRmhjQjdWa0FvNkE0TmNEUTlTYkgxWHNxRk5KWGVpV3dodW03YXBsWnBjdEpQU0c2bWFkc2s0WDdycEtscjg4bVZ6NjFSNE1FQ3oyTWRVT0Noa3FkdUtYbmxoekZRTHU5ek9tYW9tRTNaRW9sUG1ZSks1aDlEY1JEejZaUlhqUXVwNFg0NHpRM2lIOGpZc1l0MERjMlB4ZkJKdEVqdWp5Y2w4R0ZwVWxadGpla2hob3l0b2VLanZ2QlFwcFdIY0s5ajlzNHJRekVybDF4U1JGWVRXZGRwVVBBSGpjdlR4SXJUZDg1TVBHaHZSTDVtQ2U5dFVxQUNZYkVJb1hfcmYtdEM3TDRvUGdjZ2FzZlNBZlNUaUZWX2dsQUNvSWhKcGZBQ3RBc3JJUldXM194SThmZmMtZzgxVWNucjVUcEsxQm5RbmtueDZSaEZ2SU13Rl9pUTZaOGxKalI2S1ZLVFJJczA5djVxLUtOb0JISmhfOFRZU1BLNkxYckRDa25tWnZBdFV6dk1ZdEdFMFBOMi01YW5sMlpCel93YS0zRll3MFZpbHNlbl9jcHJiYlgtc1BmQW5PZnMyMDZheml5bmJwMGZ1WFUwVXVjSlZpWWJHcURkVjVvcnpURVkzd3hLTGZ1VGNyNkZITElwZ1k0N2s1ZWJEUXllS1ZaWXdMTV9DZXdGUl9lbUNMVzk5U1R2NUcwMXZkVkp6bjhiOTR2U0FwaVFGU1hQMkVnRTBsckRjUm0xQWp5WGNHSkxkTF93S0pTa0NGTG5qbDRDNXFBRkQ0UG1uVmVnMG5QNlFqdlZyWnQ0LTR0bjJRb1FZY3VIUGNYLXBqU05tMG90QVAxQVh2d0xmdUtVQzYzb3ZHeXY2YmZTYXpCekRTdTB2V0pIS1RvRGVlZEY5SmgwRENySzFqV0tWaW5CQXlJWGQ2c1hpQTlfWlNid19fZmdoUDFZLWZmNGdjOVpNMnZrQTY4SU9WMGtiSkpEQzNfY1JxdldZdjU1WDktakd2a3VSemNkbHVMTGotN3k1QnRrUF9OTmNJSi13LVdFaTNXaWo4d1pKZlFQWk9VU28tYy02QjB3dzlxbVh3bUR2WE5ZVGtwUExaTWtmUDZuUzVkM0F5cEE0SGpBd0ZSMFV5bmdZc3BReGdxeXBpcnlCYkwxMHNrSS00b3lVM1d5OUJLVlRFNGR5LUx5Z1NMeEZPc2ZBLVkyanNfMmRUaVdfU24zdEFIOVd5NEZmdWF2OU1HSW5xaXg0RHpieHlicm90LUlNa2o3YjZIXzV5TWJMRXdXamRzSjhRZDZGb0d5NHhQdUNVVTBUbEo5NnlwZm9xMlJzT0hJUnp3Zmd6dm5MY1pId3JWSjBhV3Z0QkJ6dlU5emI4ZnZQU0Y2LWUxSklUM0xnQjdBYWNjdFAwZVEtaVp4RDEzZWlXUzRLVkhRSjhUZll6YVQ0cWdEY3BxMkRDMGpxelVESG82czUzMmFZcGNISV96S0Y3ZXhCb0s1X0lXdTAwT3hyME9aTElPeDJ4UjZlZm1kcWpTMDJYd0FMY2oxLUFSNzAzMTVReUYtbDI2YmtGbHZpd2FrOVJvTFMtcVptSlg4ODNRRUhtckVFR1ptUlZWRDFZRDdUTHN3d0stVWlwaGlzY3B1RGNxQzhwYzdTUUdOLWhuSFNBWHFQZTVNV2JoellPOEJFNVRSNTdpc2oyTjBBYzktdkQwQ2o1UUxHT0V3M01OMFBGWDJ1eGtsaVE0LWlLWlBpWmtOSEk5TlJnLXN1ZDFSYjRJemVZVnd4Mkd4Q1YzZzNzZ0d6cHFBUVdFOXBEZ0R2QWVkcjFoOGZ6bllIczNJTExjZVJpQlBMZ2NveXVXM3J6ck1WbXp6bGFNLXgyMl9ORHBBSEQ2cUZOMzFSTVoyb21raUw5YjB1ZmVFU3BEOXJnRWQwanZBejlYbjRmUktibWlNYnZRWnBpMmE1eEotaTZ5WVJNUS1vTTh2Q09zb1hxblBMNDVJOEJsa2hxcFk1UzdvR25iR0tEUG1HbTVJOGtGbU9udU9UcjhwLVNHamFPdXdXS3NpVEVWMXNRSzRic2JsZUJqMDlnUjJHWjFPbWhIT0Npc3ZvcjFyQjFuQUowcUFzbnFtVDlST005THNOdWk5bVR1ZC14WUZuZzZTZWZOQng4QkFfQThQTU11S2c1d3RDV2Y2N1lMSHdOd0NJOVIyeG5yZ010Y29Yb2t2WTlWNFBNa25hQ0dQeW9nbm1PZjhkM1BGNVBXa3NfSDJuMXZhdE01R0g3Znk0Q3RTSkpCcDFsaXFFZEVoNkhnYkJGeXE1dDB5QnNVZHNjRWdqZGtpSnBDUldlZWZFZ3hiNTM0b25wUDFCMzJHWFQtNVJsbG9tdU5oQVlyUFExVTQ5QmhRM1RZLUZJSHA2aTJwNjFFalZNVGdvY3o2UkpBdFpYdk5veDJqN2dXbWJxVjZxZFFLMHhiaEd3dml0aC12dUI3S3duTXhWM2hfM3pvX2VndUI0RU1relJfQmdfQzR2Tng0bFVCRV85cTJRSjRWSEFyRzdfX0tSZXlqS1MtdklWdXVMOTcyWnFPaE44eGVuRllnNFNvYU15OTFBaDFaX3M0cGJHNzEzcmc2ZkJiRDFnR0gzemJYaDJhUmNHYlp2bUFRaDlVMGlXc2JHbzdpWFZwRmk2ZkppY1NGam55QThzR2FzUFFfVU9GakdsTnBzX2JIQWQ5QWtzQWV3aExpLXJkVERha2hZelF6RVdmZEdPcFNTRDRkUnpHMi1FRXREQ0FkZm1ZQ0NBUXJxYUNJUTJ4cnNYaEc3OFphcU9vc29wOEVNeUdaQ1A2Rm1Tb0NPYWFOTWgybzl6MFRRZE1XOExlT3JEZ3BGbElMZXRERXJkS1BxT1BuMHdfbkFXYThkQ3dRaDcxME5nclZ0X204QVBNT29RdWxVc2d1UDZxbGpNcGxVNHg4eklMSVVJMWhXdUpfeE50U0VhNjJ4VFBqZ3BqcWpLQjRrVS0tM2NQaEdqRnV4cnZLcEYzT0JfUURFWkpjbDc0UWpPVkJJdHh1QnExRndQQlFodE5wbzd3TTI2WHcydkUzYWdWNXFnR3N6MVBfV1I4ZW03a3ZvZ19HbG54SzNFTWxvMlg5TzZxR09HRmdUQXFZUTV6VjJZLWhaNVI5QU5kUVAya0kyMUh1Qm05WUxORzJIUHozTzFuTUdSQzdybWg4Wm1OMUlZWDdXbzQxS3gyZ1VvbjVCdThhdU9pb2VVT28xQmlBYm1pZUU2ZHRKM3kyZC0zVEpfVVhlZkZGd0tGOU1rQmpRMWxyenptYTJYc2ZyT054VXBweDRmX3ZCT0liLWxrLXp6RnQ4N3VSaW95bnhjZjcyVktManVTNGpscm9YUFFfWGlRa1lqbUxJSkkyUHdBZG9LYkZaVjhtYm9Ud1NEVDh4ZjVoMEJYdGhXNFBhZU5oZ2IwN3pMYVBLbHE2S3RzM0Y2bGE4RmtaWjF6OUZ2ZlBDSkJUMTZJc1FWeHRMSXN2VV9kUUpObVJMcm8zWndTR2ZuOUVxYURwMllwcFF3Ui1ITzZqTF9DLWlfTTUzX1hOMXJVYVhXbktGUzNxUl9sZXZyTFJJQ2RudFA0SVZ3OHQ5bUFrVFV2bFF2N2Z0aGIxNGFMYUxSNGttaTFTVlZpTlBUaW9fODM1MXhvd3doTGh2ZEhRdFpZVXR2OW9ScFpnZnJQejl0OXAwTm9zX182THE2TVAzZ2ZiMjJIM2N0d0FuTHVlcEpFak1YWWY2d1UxTUo5N3RTOU9jZjZIYkU1b0xtWkRuYTdJeDdpMGNoUWZQZWRhN1JsWlBQTnlWV3dQZnVlTkF0Ml9JVnhIUURnSnpmQVcyYnVEMVRteU9YSnFXTFcxUFJZM1ZiQmlHM2ZqQkVENy0xVFZBX0dGLTBpVUJ2S0xxMFJ5Tks4LUtaVjQybmwwT0FDQXhmZkZLN1RVcnRHY3lpblZNa3N2Y2llWFB6cElNaG41WEFYd1dUQVlMV2hQNGp4VEdYZ3RzM3dzQTJ2RURWT2w1Q1pQUE9BYXlNY3JqS1Y3NzBTS1ZhQWF6cWRidllXX1lrb3ZYXzRHZE1MeTl6eGhIem50bW5MN0h6eUtid0s0U1BuU1lubmxFY2dUYjZhYXRpbHpaY1JHNE8zTGZVTWVsRk5xYlVISFhrWk5lOFZNdzZZTGtVSHRDX3o0VUYteFdVVUNodjV1bDl0NmFsbTI2enBTSGR4N1hTRnZadEUyWjdKNEFVYTBQd3dHazZST3dtbXlteXNsSTFMT2Z6M3VlSVZwbkY0YmRWTF9JZDhpV3BzMlYxNktPZTdiUGtHNXdHck5VN3IzMVRYSWQzLWJMS3NBbWs4SFF0WFRHNTg4cGpoZlktYW9QWFA2WDAwMGdVcEVYQlp5WC1zX0R5NnJZUjAyclR0ZGVqa29HWE43UjVRWHpEd2pvNXNLZHUzdVlReFRwMnB2RW5KRXA2LWIteHE4MTdiX0xVY245dm8tbm5FTXhnWkFoT3IyRnhrbER3QzNrYjVaX2Z5UER0Z1J2dGNKNzlIZGFsRFFBRDZFWW8zQ3ZyVVRCTDFubnNLaXlLOGNjTGlVWVd1Z05hUG5KNmd1Ty1WSnZoalNSaUNZM3o0VndwZVo3NF9PdFBEN2ZBd1RNSzlpSXFQbC1iT1pzUWUzU3hoLXlaZUM1VXlXdFVlUFk4Wk1Oc1RNM3laQVlObXF3akZxczNjRW9wRVpFZ1A1NU41elVBcFE4RXg0MVlvbjZibFRIQ1FySzF0VlFya3dmSHliMXdPMEl3V1Ywck9WdjF4SE1DMG5odGtQeDBKdEUyeHpzUkdCT3N2a3hic01tdDRGUGNRVEU2M1BpZF9DVko4ZnphTnRJa0ZMbkNldnVacHNvZndodWN3X2FheThhZWZzcjFhemdsdl80cVFkTkZXRFJpeDdWV240NnNTOVNfUVQ0WUdNTXJ0c2RMbTV0RDk5UHgwMmRvby1hczBndVZFeEFsTUdQZzdWTjBuMFBsbTFVbTlnU0s1MEh1M3VmMW5rdzM3Q3VxR3pSa3N5ZXZWbkZRcnBhTUV1b3pOaWhCLXhFSjFVWV9RR3ptcmJYUG5OSmFZcHRPaExzaFE1RFJvRW5KV0FGVDJDMWNDWHQ4b0kzVTlvUWp0MktOcjBoUzNlU01QZW5rOHc4cDR1WWR0STZva2poRmhKOVhzWXlXbHBfT0x5SElwbkYxd0NvZ3JMb180V09pRjhwcFN5X3ZYcUpvRWxGQzY4NmtuZjdiLWw1RUtLeXFXLVlwcS1lQkxxZlVhYzhhSFlwb1dTeUxFdFN4QnFGYjAyancwem9wOEphc0E4RzNVZHJ3U3pXWElkRDVjazljUGRhbUVNcjVjVG9BLUxmZmxZOWkwOFRUM0xpc01vb2FRX3RHZ0VMb0U2Z0lrNFpKa3YwU0lBamhPOEhjdzN0ZlhZS3plUEx0dXVJTVBOc3VyQU5vQTVnQXNNZy1XUy1XM2wwUjFwVW5rV3dkZXdXVVVXcVZEX3JSLWFxN2NnQnJiT1hqYU9VUkx5Y01mZ2FmQXR6UkRFa3pRSzVZcU5oV1g4Mnd2dTI4VnZCRGc1RE1ld3BZbnA1Y0dqN3BnSm13VVFGVmRSTGxsdG5YQUI2d3BYcEdid1RmdzJORS1MSzZjZnFoQmFaV3c5ejV0TDQ1c1h1X3dtV0F1eTZISkdab3liS2UyZXE2RkRRVy1xdy15WUp1TVJGbElWODZ0QTVoZThZb3F3TFJCMm45OEJDQl94Tzk1MlhlVUtYdW5rcDNiQThieFA0UmVSbzBXRjctb3BlV241Z1hNQ0Raa2ZtMmxXYXgwZkhRNkh0ZGRwb0VZUEljNzFQbFFjVTBuSExna29qNUk5dW9ETGt5clpHQUM1Xzl5ZmJISDg3ZFlSS2pyX0s1b0pCT2ZBX01kWDNvTE1scV9MNEJoRXpyMFFudjE5bDNiTWk3NGs5RUVaQXhKWGszVzFwWlZESG1QemhkQUtyeWVZZVdIS2VxVGdBOXRkVUN2WFZTeGs5UkhrSTRDSUk3OHJkSzZQS3EydFJpZWZOWkYtX0hsZng3b29fdjhpdWY1ZVlHWUM0MGtKMmIwd1EyN3YtNjBuMmZaYnYwdm1Bb2U3N29ZSnhGZm10a1hMTzR1MVR0S2hzODhxanNwakRQcl93Z1duVE10aTlLWU9QSlk4bWR0SE8tZ0xYNEhRaUZMTDZtd1o3b2lvaUt1SllqNmE1ekV5M19PYTJfVS1LRmxDQXltWTZhMk9jd3ZkdGQ2ZUdVME05YW9LTzRFSFJjbDdOX2x5aXAtNW0tLTVJa0x0NjhmRW5qQldwSU9xT0loNS15S0g0MU4wb3Uya1BCQlp5WDRKMTIyQWlvOFBIU2p0dzc0VFBFaW02b2tUaUtaZXZLbnF5RnhLcHFwM3IxekZub0ZTekhQekk2S3lVVW1qUlpjcUpXbk1QMzZBTFhyZktLcjFrVnp3OWk3b3MzYVkyWm93RkVEVG94cVpSVGsxak5hSTZxclBLLTF1di04YV9VWklZbDg4cTFUdVlGSlNrbFh6V01CTlk3WlFzdnl5NndkZ0J4dWpvMWFKakI2dTBuSDhKdFVWaTYyUVpaVThqWEtTMmNjQUIyZjBfU2hkNFpoUER6YW9TN3EyWGlMZk1ZVHZtN0ZJLWo4R21NM2c4cEpjYUhydmRpUUNfazlubjBydWNaMHdUU2ZDa2x2Z0N4MFZUUTcxbUZxazFZbWQwNWVKRHFkV092NW5NOE5HSnBsNDItaVdWaTFyTlJqV1dsUjF0b1ZsX1FRV3JyUjJOVFRVaDF4SnBVTlRFQlFxLWlPTGRYRnluT0NPTGJVZEREWlUyY1UyWVNGVE1WSHZyMTdnOEJfa09JSVZQYTFuemZ4MlZpREg2c1otdnkxN1p6cU8wUXJLTTNtX3BMb09PVDliZ1VPVm1aaVNGU1pzWWFFdUF0SW16SmhNZXdWSGxIU0g2cjNoTUJnenhzTUx6UWpHSzd2RFE4Vy03ZjBTaHhqNF9pNXFIalZwdXBtZkV3MmF3OS1BYTdOTmxscTRaQTFoTmZfNTU3cVV1X0xKWXFqd2FjeldWU0dpYllJNkZEZnFOcHVVcFdxajc1ZVE2MUdteEV5Q19qMFVldmZLRk5IaEVyNktMOU9YRDh5ZVRhZjRrT0doYjFFMlNXZ29wanN1ZVRDMnhoS1UxZDFxaWVyR3JIaTZ4TEhLdVZzVmhiRVlsU3JYX2c0OGZXQk41MzkwZmhNLTh6OElHRExVYWF3TkQ0WUdMUWZET1hsZm00ZVZaSHd4cFIzOGlGNE5VbkswWmNkRHdlRTZ4dDFUbG4tSEI0aDJHcUk3R0NIb1cxQWpiSlByREdnbjZMaHYzTTJVSTVMUS1FZUc0TExWMWRnQzhvMUZPLWlKNm4ydHNaVlUwdHhrTU1TaFdfSFd2YXRldE1yQUNTZGNMS2lhWHd0Zl9TcVA2QlNMV3hqOW1wLUs1OV82TzN2UDdWSDRFWktqRG45dXEtdlFGN0N1X213U21RZWZPUDhTc2drVUl1cFVkXzA2QS0xZWxmX1pWaTUxMjB4OWJnN3gxbWRZUkhxSGxhYnM1bnd4NW9xTFNsXzRFeE1nMFVoQXd4TVZZYmJOT2ZjQUV4eWd5RHVSek9SaFhDZk54U2dQZXpKZXpVcnlxbHV0bUs5ZkpHaFQtUG9GTVQ0VHVmVkt0OWJSVmh2UTdfU0pLZ240cVBMR3VwWGJOSlBNSnJFNC1XeGlzLUM2Q0RCWUxycVJCZ1lMQjJ0bzdYQzFER2dMMWY4N1BYdmozOXpXX3dOS2d1c0ZpNzEtQnBWaGVjUTkyemJGTEhNX3pYeTg2akNBWkFLelpHYUtXY1FHZW82anZVRGFZTkJEUHl4VGtma1pxOTB2SjNjTzV1djNwX1FXaHk3TmgtWkVCWTJrby1RcjBhVFVselNGTThaVlBqWmhMR1VOaXk2bGQzVFFEMGR3Y09lS0ZabVNTREVLNWMyOU9mVUp1QW1hcEtjSnc5UklpUTdqRXJ3SUtybGEtQ25selI2MkVmVWQzSVdwbnlsLUV6UHcxbFkybVlvZC1JcDB6RHVwRmVhczBKajcyQktNQlNxMEhaUmh2TWJ3cERSMTBnWDlfTV9mcnhWZGpGWnUxMGxrTXNZWVVrOGFRbVFiTlBxMmFpRlVyM3h3Y1AzSy1keFlEUkNYX0tONFo4cTZRWFdjWTAweWw5SWdHOE9aalhVSzZyVWYwckFiUHNhZjFzNnMzb0NuSEdka0NoOHNRYkR2UXdSSmIxeVFLLXVRN0ctOWpGb194S3hrdkVIa1dsUm1nTURFTzNEY2VBb0VhckFwbGx6TlFINldCWUoyMFpWN2lhVGVtelZxakh2SUhCdExiLWhYMTZDT1ZqMnBuajRKUWtEMXNJY1lxaVFjeTJHMGktRy16ZWd5QmVQSDN1NzRwNG51V1g0d1RMX3ZKeVVoLWV3RHdnOEdNbjk1NngwYTRtYThLeU1kR2pHS3N3aHZKQVV3ZzVZM2ZYeUU4MG91M1FQTC1OZXh6bVhYZXNfS0dfckZPcmxyYlA3dWhYUlZ1c3d3RTNiLWVUT2dFY3E5NlZCeEljZkFjdnZiSVVCUld0LVF0RkR1aHdzZ0V5aDdBODRtd05DY0FiWGhWcXZQYmpzRjFYT2VSQmQyLVBZM3pxemNUcllpZWdKUUN4ZU5LYkw1UFlSaVZhdURTRlQ0YlJkM3F0c1hNNkthSUFqUEJpZFlQN3FUaUd6a3hpYlQxNjRoYVFRMVNLRHl0NXZ6dFptNDVkSThkdFRwX095Q0tJWFNMQkRUSml6bUJhRVZFdElrWUNpR2xZOE5Kbk01bEpjaDR1NHU3NThGQ3BaMzQ2aWNJS2lnbzdubmtQVTdJbmdXVEdQaXZIQlFPbS1zdG13SnpxR21yWkw4QUl6TnNWbDd0ekpOQWhJWDduNDE0aWFZMVd4cHdVa2dTSHNibXczeG9DSzZieXh4TE5mTnpiRDVodm85cTY0cEtTby1FMEJhLWtadUJpT09SeWtNSG51M3BXck10SEZhUlQ2dmU2Q00wY3luY1RGQzRRTkgwT3FGX3dBWHRYWl9tODhJX3NGTTdUbHc2Qmxjc1lnZkxodGVpYzJDdlZYaXVHMGdId2ZwNDAtZE9QM1FSd3VZaXF4d2hKVWxRM0dSOVYyYmFFNThtQkU0YnlNMURnc3BRY05qS3VaVHlKVjNCZnNudlRqY0lRcUJJTUZVcjVwSTRXSUxtTjUyWlA5MWJWMTBXYVY2MTZPQk9BLU9uUTBGRGlxVFJIaUt0RVl4VDl1QzBmXzVoNDJlXzN1S25HalJYYnhQRFdUbjBOZS1jUi01Wk1XSkpfN3VBT3YyZU5iRjhWMmtYbWktOVE4a1doV1NvUm1OOHFzdHpFdFZBLTNSQ09OdmpxZ29UbzlfU0htUGR4TWVWUXdldGQxZGg0MHZ2QWlLY1Jmc1BBUkY0MTl2Y2hFZF9GNWF3MGpFVFZCRFlBMmVsVXkzdkx2V2tQTFNEQU8zdGJwYlJTeHNXUnpOUG1SN2JOM2VZWFpRY2ZTaXlpMVFmZmNpX1FqQVJIQTVsZWVCOEdCbkFDVktBLWFnOEZsOGtSaV9fYUxjWGJqWjJMTFlObUpqVktEaGJMOUZUUjgwWUJnVGplU29UUHY2TDBrQS1PeTd5RzhLcEUyREhYX1l5dnFOLXFQalc1eG04RE5CODF1OTNIUzVXLUU0ZS02V0thUWNOdEttVkJaWjg2Q1h6elZOZHdTRkRhOWZNenVmTDRsR0NVOE15QmlTVzlYdTdadmpIVTRaZ2U0cmJHaU50YVVTR3Z2Y1d3dldGUlYyV0lVb3pvTlV4VUI3U1FMcUl0aWZtclJpMDhQZ3VaaUNlcW1jV2c0S3NQMWs3NE9pckpfeXV2XzFYVjVwTlZxVlA0NnpUc2R6NjUwV1VYMGtzckZNc0RPSC1vZjI2dklmUnpPRFhIcUNmYjA1STBtaTlJaUZuMlNhT0gzRDFaeEdvZDZST3htOWNCZEFJUkdkM0FkYTYyTlhrVHczSnpkNTY5UzNlLXg5OFRIQlByM1VoTzVUcUhKUHpyNFJiX0Zva0F2QW9HS25uSDdlM2l4ZkI2TjJIdFg3Mm5BSWg1d0QxQnAtV1kyOHgwVmY5Z2tZR1Z2dklBTndJTDFZUzA0Ukp4VmoyYVUtUlJqd1kwVUtvd0Yzd0NmTWNmdnFERjdPQnJ3cm9OWlhQUWlQamRXOXRiRkdwVTVEUXZHbnVDRnR0U1ZGbGl0UTZWMG1qVlpVVnROckNtNmxpclQwbTMyZzVpNUh1dFZTQ2JEMjBGNVhBMHBLczMtT2ZWWXY4cVRpbHdHc1FvZDhENlZTMU11RDEzVHBhaFRXUG12WTRXcEFQdV9RRkl4azdMNFBTbXhOWmYwNVlEWHkzRFAtTVluVG1jX3I1SktwVVFONjVhWFpCYzZfZ3Z4dzl3RHZJNFNEczhGMGRNQ1NFOHk1cmdmMUp3N1BVV2w1aHJ1TU45NFB2ZkNVY2dNQnc5YXlzYnZDZ3JOQ3lsaFdqblJtMGZQb1JYYmZIUU5NU1R5eGdndUVycjNwQ1ZiN2pBWmZ0RFFSNFh4U1VxcWNMT2FjX0pqbmhmQm81QUM3OHVubmdRZ21RVUdvNlk5RFFjSmNlUEF2bnRrLV9fNVl1TUVyVDd2QlpmalAxd0U4Zkw2VEFSUm54RUJ1OUs3ajlZS1ppZ0tnb3c3LXc1WW96YS1rdUtCOS1CTG43ZGhjWEwzRFp5ak83T25sX2JJRzJPbjR2NFhVZHk0OC1XZnUySjl2VC10MUxRVWFfLS1TTDkwS0NjcTJRR2RIVDhrZ0ViUUdFZnBUN2VfUFhSaDdlV2dnQ0kzenBod3VyRVd3Wk1TSF9sdmV3V1l1M1Y4eEh6VG9oVTRpNTFQM2pCdkI5MmdYc1ZUUFRaY21ocTFKU0RBY25qWlZ1a3lfQ1lva2l4RVE2VndQWTFFaUlZZ3hxcjRsT0o3a2tXaHV4d1dIUEJnNF9wR3Y1SFlSc1NWX2duakR2R2UyNTYzYTE2RDQ0WDNEbGNjUVVjem9kS2x3UDZtWXhKbjdhVjZweXhqb1dkV09JeXBYdVhxTFJNRW9kNnRMMmZ6OW9xaGNMQVh3cWdfM251a2p0a05jakNXbV82T21OYVdnVk51NERGTGNjWmNoc2R6cC1ud1dJYWFSOVdQUHowYnN2cVdNUHFuZ1I2VF9rdk1JVGRuTU9QZG1RdUZQYmJiWElJcjdnbFVYNC1ESVRpeE84NGNzdWF5ZUF1U0loVUE5YmFMZG5IMFdFNDlsZGNROEtuV0hWVktpUHd3eVRUT21CTlhjUTFDWDRhdi13ZDVzMnNsSWtlbUNnVUdELTZ0d09kZ1VGYlJFb0dSR3VWbGZ4NnJoVGpSWmpxZlk1cndKcVNya1VKaG11VG9FaUQ1SGZtTTR1N3lvZ2VVTXRMZGxZVlhMblQ5NDRHZE9tVG9jamU3OGpybmViZFhHaU0tTHIxTndoV2gyVXJkWno0THI0c2FZS1plQ01HcVlLc1V3WE5abEViSTl1S19nRl9fQlpoQ3NqWDRFUjh6RTRXbGxDdlZHaEdKRkQ5VXRWaE9EZlRsamp6X2NZY0tKVEFtNVdXY0tWRlo5ZTBzVndpNElrbUdoLURUZGRKOTk0ZU9uc09qSG1MVHlvVmtrSUdhbzJnLXN6ZDFMS2w5bEVRX0pUWkd5dzlxMzJRUjZ5M1VUNFlaTjZ3bTRFMzU4ajBEdktsU0FoZGpHeTYtbWRHbEVIbW9QYnpzbGNOUWJWbVZGajFOY2Q2clUxaS1lelJqekZEalhQeGxVMzgyZzBmY2tzM2lYQnJrcThrX3d0allSa2JlQV9DbC05OUtiZy1RaG1neVNQZjlRVlpSN2RBTkplS2RaZEhrSFE4RmxQYjJ4eFlXa204Um9RalNsVm1jeVJodjloR2ZWZ3pIYS03VEZGVE5wZXFSMmVXR09HVl92S1FtajZlQ1dRUWNPN3FTZndWb0RaX1JVQS1PdDZuVGw4Q0VQRjI1WnBHZXluSV9jdGJCMV9WSWRMMnZzSl9TcW1TMWJvc0cwcXhPXzVtdmoxSkhEeDZOejUxdVF2UVplQlNpazk2Ty03cTd1M01vTzZvRm41MW5YYXVocjhWeG53dnB5QXlVRHlTanBTbDczZVhWdGtOdUN3X3R1enhZUFBFeWtOVkp5d3RBcGJET0psbEVMa1pEdmFKaGVzV3ZuZjNfcmlUZ0ZyTklMd05vYW9kcUdQay1HbVVURFBjcEEyRzcxUnI2VThlYmdPNFhQQWs1R0FaTEUwM3lrZFFXcXQwZE0yME9pNjQ4S2hPTVh2R2xuR0s0Z2dRcWNzMUhWTDU2VFlRdG1LRG84dEU5ZE4zbFNmZzBlVlVjSzh0Z3BNZ1hvWVdWcldHTnBveENzd0dlRmdhc29uNFJ4RWZRSko4OHJYdDRsNGZGb1RLWW1fckFwOGlfLVdwTDl6bGpOdXZpaHU2aDdPejQ2Y2s1cENDV3dWTHMwNklXQzdaRXRlNjV4VnJzQVZUQl9pRGlXbG5obTJFSFg2RzBkZUdmS1RnSXlVRnhGUnhXaC1QZmt0NGs1LU5XVnVEVlUzZW03Mk9yRG1wcVNDWFR2ZHpNb0xsSXkwazN5engzYVNaVE1aa1BoeGdZRmw4QVlxZDFsMnFPSTNxMjZrZ0s1SndHYndvc2pORzRJVGYycmpPazYzdnlCajJSM0x4OEdVUEN5SVVPZVpkOUJzaFZHTkwxT21uWGpTUGE2b3ZLZ0lWV3NvZExDS1cwVWYzWXA5T25HeG1aZVJLWXFSMndHcEFqNlhNUE5feVFRUFpRcG9Da0dPa3BvSVhNUTVxVEg0eFl0dklTVUhYVjlUNnBabXpWRGF2b2M3ZE5OYlptaGg5dGxCblo0RjJTcndzSEhMeTZfelFvQUVrcHppNWR2WDhBTWZOTW5FeDRodU9wRlFXSHpzUTkyYUFXdTBnM1UxQTBsMW1vWlhIcFFaNXd1WDdZR2QyNW5Xd1dOVllLLVAtallCeGpyWmVNbVAxWDF2RGdLb2lTZDBQdXNHcGQ3RUxORnJmTEFURURJRFZ3Smx3RWp6TnZ0RFRFLUxveVlUVENuNUNoQUpTdGN0OGgxUllzaTY2UUk0a19sV202NkdLTE5ucmVaQW9LQmRkQTNrQlFBSnVjWGw1WmFRQmZ5b3AtTk5CWDBZcVdEVWNuRG1uUGhEaWVoRzhIYWZxbTRGcTdLRmJJcGxhaDZHSGJPY2ZwNFZDUHo0VEdNZ0gzOGcxUnFBdnJqdndrV3E1X0xrOGkwLUN2N2UzbEE5N1JnbWIwdXJOMGYxaXJ1aFROSXhpRjV5WEtMRXV3eHRkcUFtR3NheTdxR01oR01YSzZSQll1OTE3akhmZ09uQ1dNcDBkZllyWmxINnA5MnpRb3B4aHNhekVhSFVGVEZXRHdVSWd2S2NCSmxfRGdnVmY5bHZDME9WZFZVVVlSbVd4VGZXOHZwOWdWN21YYnZtNThMVGx0cHpBQm1uMVZGWnZrZGREamZ6bmNTR29PSHNlU1FmVG5KSERSX09DYmJYb3FyNEhfSDlUSUxabEpubmdPSDlQbkE1aWNtMVFnSlJGT1RpRlZZTnZzX3dRbXJKSW10YlpTb1hZUTQwZjFia3hLWnQ5RjU0RFFiaDF1dGJpOVFvejRuWEdwYWhnOW9yMTBUTHBKTlp6V1ZUX0ZiX1gzemNYVGZldWxkMVdKWHVDb2NCSzY0bFIwVVYtQmJSaTRyUFdwQm9jdWJ5eEpEX3RhMjBkTkpZSG5MMThSa3dObGhqcmp3ZmlhRG14SGw0WnMzWmFJOXVxemh2YnRweGZOa2trZl9qSktfdmNHYnQyeXNBcXBvb3k1bGdLbXR4bUhGSXlZZXpGaUVKeU1wX1ByU2x2QnZBSXEzNDZHRl9GNnhzRko1dWM0TVlnVklBd1BubjdSYzdMc3dsX05ZOFJGZEF5WjRLSi1xSFlWZGdVYndpNml0anhVRkNPTXhlM2ZvTThXUEl3RG9WOTB1YXBYT3RQb0E1cnkyTTBOQ3NZbUhhVFcxYVhKanR3WHVwajRmV3A0dlFiZk1EWHVHc3o4U3RhOHhvV2xuUlhKdDJBY3Zwa0VGRnNmSnpyTFh4LUt2VWRPa3RSRzd1WHBLRC1iYnpzOHgyWGhXd1FVVmx6YTFSeDdOaWN4bXV0X2U2am55YXZWQWFMN2RubWxNeWdBUFVLTkxCdDh0SHRPb05YbERZbmZBUldEUVNiR05yN2E5UFhDU05DZ19CVnp3clZHb1lRbDhrcklRTlZpVk9WVGtNZlhtbHlUQmVrYVJrYTI1eWktVzRJVk9ESHRkS1VvVy1ZMHIxX2ZlTWtvWVk0ZzJ4aW1ORDdwbzVSeWNicDN4WGx3cU4xWHZJTjRQY3lWMVdlQUUtNzdjOHExQmN6WDJVOFl0c085ZW5qVzJyWU81NWhhTHJMYm1Zck1JNEgxalMzbXN0cThWU2o0UXpkTW5VanVfdF9aVmU5akdlVDFrcXZJd2JPcFNTN1g0OEdndXo4SVMxZHdIREZKQ2dCc2tyZ05jRGFMTmloeEh6dGJ0Z09vZjhhRUlBTWJuSHFRX2NHdGlleU91a0ExU1k5Mk5tWTA2NC1HcHN2RXRmWWlIdVJwb3Z5TkFnSVRXeks4WTh1Y05rZl9hVFdxR0gtZ3pDazAtNEZyVllMWGl1OHloeVVjSFJLMXdxVlV4bHZsWWJXWVQyaDlrVjlqVkU0LW05VE1nckJxRDlodEt0aDRUN2VES01TWGszcWJ1N2VFQmJBWjMxRldUUVc0T3lPclFXMmZoa0pfOVJ3OV9jckJvY3NJS3ZOMWlqbTlSMmJUMzIzZ1pLNW1FQzEzZ21FUURrT29aUVBZdm8tdVl0TzJEYmkwdUFYZXJGQUJUNlBJbTFrTURQV2J6dFJuNXptNTZqbVF4cDI4U1hmZ0ZzWS1UdmstX3FoUWxDZVlpUl8tT0p4cEoyRDdCYUV5SnpQZGFuWkJ0SXpzYXI2RUFVMU9CWEpaZUM2YnZuRlZIcXBSRHlpWHlvZHNYM0xpal9qTG5zYnJjamFad1RqRHB3c0RhbHBPeURWTV84YVJHZXZtTUI2Q0JHdXpvVmVKamRsaDdlWnljSzdQa2pKNWxQeUI4aUpUOVU3cWptUGlwaGRjLVZOSDROaXJCZjhPT0dJOEd0ODl6Rmt6YUFkUmxDYW9SWll1SmQ1ZWZUS3R5SEZFYlEtWDFISEJsS2hhMXVCdDVZOEQ2Qk9aeVp3MzU1enBvaUM4elFWcW5LMmlwRGlHRW00WmR5bnB2eElGaDdYMXRwZDVYcmZfd2JPeDI4UjEteXkwako4MjQ3cGxHLVBWVjFHaHFNWU1DejE3a3dKcEZFckxOLUk1ZWdFa3JkZmNlYkFiUE5vcGw0aWZqWXk4N1I3ZUE2WjZMdU01Q2VaTVhscE9kc0pyX1FwR3g2ZVVDLUJjQnU2M1V2Y0VRRWhUUWh1bjgtNl9DZkt5dW5HdTd1dnVtNFRxY3ZOM3lpM0pQdi1ka1l1TTNWVWVEbG5ndThDeU94dTlBcE5IQnRoZ0JsS2NrOVgwSnlfSTBtRlhWRTZDUDM5MGczWXBzbjRSNkNIcm16SGFEV25jNExWdWg3TUpxV080WmoteGVhc1M4VTRwUlJGaXZoblJhN1JycF9BdERtRDVXcng4RC1sM0NrclNnX1FzZVA5UFV2d2l2a01jZklQdHlzdy1TMkFjdkVRZUNMWEg1S2hIWHA2QW9sdndHUHRKZXExRV8yQ3RUV0lhdWhIYnNVX1ZWQnF0eGJtSzBoSG43VU83TmZxTlV6SllSaFZHbXo5SEY3Q0dCOVBLMy1kSUJxQVNWWEN3OGpGTmxOaFVFWVJQcXR1NWg3cWsteHVQRGNyQl9QSTVUSTFtNnoyUmx4aXppR1ZXM1JyaHpSLURMaDRGalp3YVFoUlZqUGJVUU03czZic1VnIiwiayI6IktVVldNRElwY1ZkM2NrVjFObUl6VDJwUkpIRmhSVUl6VnlwZE9UVlVNM3QyVDJSVlZIdEdTbGRvUlZKQVJVdGYifQ"
layers = 3
iterations = 600000
try:
    data = _b64d(payload)
    for _ in range(layers):
        obj = json.loads(data.decode("utf-8"))
        salt = _b64d(obj["s"])
        nonce = _b64d(obj["n"])
        ct = _b64d(obj["c"])
        embedded = _b64d(obj["k"]).decode("utf-8")
        key = _derive_key(embedded, salt, iterations)
        aesgcm = AESGCM(key)
        data = aesgcm.decrypt(nonce, ct, None)
    source = zlib.decompress(data).decode("utf-8")
except Exception:
    sys.exit(1)

exec(compile(source, "<shadow_core>", "exec"))


EOF
        # FIN DEL BLOQUE PYTHON PROTEGIDO V2
        
        log_msg "SUCCESS" "$VERDE" "Núcleo materializado con cifrado SHADOW V2."
    fi
}

# --- 2. VERIFICACIÓN DE ENTORNO ---
check_env() {
    log_msg "SETUP" "$AMARILLO" "Verificando entorno de ejecución..."
    
    # Python
    if ! command -v python3 &> /dev/null; then
        log_msg "INSTALL" "$AMARILLO" "Instalando Python3..."
        pkg install python3 -y
    fi

    # Cryptography
    if ! python3 -c "import cryptography" &> /dev/null; then
        log_msg "INSTALL" "$CYAN" "Instalando librería 'cryptography'..."
        if ! pkg install python-cryptography -y; then
             log_msg "WARN" "$AMARILLO" "Fallo nativo. Intentando compilación..."
             pkg install build-essential openssl libffi rust binutils -y
             pip install cryptography
        fi
    fi

    # Requests + BeautifulSoup
    if ! python3 -c "import requests, bs4" &> /dev/null; then
        log_msg "INSTALL" "$CYAN" "Instalando librerías 'requests' y 'bs4'..."
        pip install requests beautifulsoup4
    fi
}

# --- 3. EJECUCIÓN ---
auto_update "$@"
clear
echo -e "${CYAN}   ___  ___  _  __   ___  ___  ___ ${NC}"
echo -e "${CYAN}  / _ \/ _ \/ |/ /  / _ \/ _ \/ _ |${NC}"
echo -e "${CYAN} / // / ___/    /  / // / ___/ __ |${NC}"
echo -e "${CYAN}/____/_/   /_/|_/  /____/_/   /_/ |_|${NC}"
echo -e "${CYAN}       SHADOW INFRASTRUCTURE       ${NC}"
echo ""

generate_payload
check_env
check_ip_range_ifconfig
log_msg "LAUNCH" "$VERDE" "Iniciando Servidor VPN SDC (Shadow V2)..."
echo -e "${CYAN}====================================================${NC}"
if port_in_use; then
    kill_port
fi
python3 "$SCRIPT_TARGET" --port "$PORT"
